{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n  const returnValue = func();\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n  return returnValue;\n}\nfunction checkWebGLError(gl) {\n  const error = gl.getError();\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n}\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {\n    return true;\n  }\n  return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n  return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n  const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n  return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n  const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n  return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n  const lineNumber = +lineNumberRegexResult[1];\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(`%c ${util.rightPad(errorLine[0], maxLineLength)}`, 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\nexport function createProgram(gl) {\n  return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\nexport function validateProgram(gl, program) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\nexport function createStaticVertexBuffer(gl, data) {\n  const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n  const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\nexport function getNumChannels() {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n  return 4;\n}\nexport function createTexture(gl) {\n  return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if (width <= 0 || height <= 0) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n  if (width > maxTextureSize || height > maxTextureSize) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error('Requested texture size ' + requested + ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\nexport function createFramebuffer(gl) {\n  return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n  const loc = gl.getAttribLocation(program, attribute);\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n  return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n  return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n    default:\n      return `unknown error ${status}`;\n  }\n}\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n  const tOrNull = callAndCheck(gl, () => returnTOrNull());\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n  return tOrNull;\n}\nfunction validateTextureUnit(gl, textureUnit) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\nexport function getBatchDim(shape, dimsToSkip = 2) {\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n  return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\nexport function getShapeAs3D(shape) {\n  let shapeAs3D = [1, 1, 1];\n  const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;\n  if (!isScalar) {\n    shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];\n  }\n  return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape, isPacked = false) {\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n    // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n    logShape = logShape.map((d, i) => i >= logShape.length - 2 ? util.nearestLargerEven(logShape[i]) : logShape[i]);\n    // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  }\n  // If logical shape is 2, we don't squeeze, since we want to match physical.\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n  let size = util.sizeFromShape(logShape);\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    return [1, size];\n  } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {\n    return logShape;\n  } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {\n    return [logShape[0] * logShape[1], logShape[2]];\n  } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2]];\n  } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {\n    return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  } else {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n      const batchDim = getBatchDim(logShape);\n      let rows = 2,\n        cols = 2;\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n      size = batchDim * (rows / 2) * (cols / 2);\n      return util.sizeToSquarishShape(size).map(d => d * 2);\n    }\n    return util.sizeToSquarishShape(size);\n  }\n}\nfunction isEven(n) {\n  return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1, shape2) {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n  if (!shape1.length || !shape2.length) {\n    // One of the shapes is a scalar.\n    return true;\n  }\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {\n    return true;\n  }\n  if (shape1.length !== shape2.length) {\n    // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n    if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n  return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  }\n  // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n  let queryTimerVersion;\n  const gl = getWebGLContext(webGLVersion);\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') && webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n  return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n  return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n    }\n    return false;\n  }\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n  const texConfig = getTextureConfig(gl);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\nfunction createHalfFloatTextureAndBindToFramebuffer(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\nexport function isWebGLFenceEnabled(webGLVersion) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n  // tslint:disable-next-line:no-any\n  const isEnabled = gl.fenceSync != null;\n  return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(t.dtype !== 'complex64', () => `${opName} does not support complex64 tensors ` + 'in the WebGL backend.');\n    }\n  });\n}","map":{"version":3,"sources":["../../../../../tfjs-backend-webgl/src/webgl_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext} from './canvas_util';\nimport {getTextureConfig} from './tex_util';\n\nexport function callAndCheck<T>(gl: WebGLRenderingContext, func: () => T): T {\n  const returnValue = func();\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n  return returnValue;\n}\n\nfunction checkWebGLError(gl: WebGLRenderingContext) {\n  const error = gl.getError();\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n}\n\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\n\nexport function canBeRepresented(num: number): boolean {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n      (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n    return true;\n  }\n  return false;\n}\n\nexport function getWebGLErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\n\nexport function getExtensionOrThrow(\n    gl: WebGLRenderingContext, extensionName: string): {} {\n  return throwIfNull<{}>(\n      gl, () => gl.getExtension(extensionName),\n      'Extension \"' + extensionName + '\" not supported on this browser.');\n}\n\nexport function createVertexShader(\n    gl: WebGLRenderingContext, vertexShaderSource: string): WebGLShader {\n  const vertexShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.VERTEX_SHADER),\n      'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n  return vertexShader;\n}\n\nexport function createFragmentShader(\n    gl: WebGLRenderingContext, fragmentShaderSource: string): WebGLShader {\n  const fragmentShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.FRAGMENT_SHADER),\n      'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(\n        fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n  return fragmentShader;\n}\n\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nfunction logShaderSourceAndInfoLog(\n    shaderSource: string, shaderInfoLog: string) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n\n  const lineNumber = +lineNumberRegexResult[1];\n\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map(\n      (line, lineNumber) =>\n          util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(\n      `%c ${util.rightPad(errorLine[0], maxLineLength)}`,\n      'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\n\nexport function createProgram(gl: WebGLRenderingContext): WebGLProgram {\n  return throwIfNull<WebGLProgram>(\n      gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\n\nexport function linkProgram(gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\n\nexport function validateProgram(\n    gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\n\nexport function createStaticVertexBuffer(\n    gl: WebGLRenderingContext, data: Float32Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function createStaticIndexBuffer(\n    gl: WebGLRenderingContext, data: Uint16Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function getNumChannels(): number {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n  return 4;\n}\n\nexport function createTexture(gl: WebGLRenderingContext): WebGLTexture {\n  return throwIfNull<WebGLTexture>(\n      gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\n\nexport function validateTextureSize(width: number, height: number) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if ((width <= 0) || (height <= 0)) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n  if ((width > maxTextureSize) || (height > maxTextureSize)) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error(\n        'Requested texture size ' + requested +\n        ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\n\nexport function createFramebuffer(gl: WebGLRenderingContext): WebGLFramebuffer {\n  return throwIfNull<WebGLFramebuffer>(\n      gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\n\nexport function bindVertexBufferToProgramAttribute(\n    gl: WebGLRenderingContext, program: WebGLProgram, attribute: string,\n    buffer: WebGLBuffer, arrayEntriesPerItem: number, itemStrideInBytes: number,\n    itemOffsetInBytes: number): boolean {\n  const loc = gl.getAttribLocation(program, attribute);\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl,\n      () => gl.vertexAttribPointer(\n          loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes,\n          itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\n\nexport function bindTextureUnit(\n    gl: WebGLRenderingContext, texture: WebGLTexture, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\n\nexport function unbindTextureUnit(\n    gl: WebGLRenderingContext, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function getProgramUniformLocationOrThrow(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return throwIfNull<WebGLUniformLocation>(\n      gl, () => gl.getUniformLocation(program, uniformName),\n      'uniform \"' + uniformName + '\" not present in program.');\n}\n\nexport function getProgramUniformLocation(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return gl.getUniformLocation(program, uniformName);\n}\n\nexport function bindTextureToProgramUniformSampler(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    uniformSamplerLocation: WebGLUniformLocation, textureUnit: number) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\n\nexport function bindCanvasToFramebuffer(gl: WebGLRenderingContext) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\n\nexport function bindColorTextureToFramebuffer(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\n\nexport function unbindColorTextureFromFramebuffer(\n    gl: WebGLRenderingContext, framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\n\nexport function validateFramebuffer(gl: WebGLRenderingContext) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error(\n        'Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\n\nexport function getFramebufferErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n    default:\n      return `unknown error ${status}`;\n  }\n}\n\nfunction throwIfNull<T>(\n    gl: WebGLRenderingContext, returnTOrNull: () => T | null,\n    failureMessage: string): T {\n  const tOrNull: T|null = callAndCheck(gl, () => returnTOrNull());\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl: WebGLRenderingContext, textureUnit: number) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\n\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [\n    shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n  ];\n}\n\nexport function getShapeAs3D(shape: number[]): [number, number, number] {\n  let shapeAs3D: [number, number, number] = [1, 1, 1];\n  const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n  if (!isScalar) {\n    shapeAs3D =\n        [getBatchDim(shape), ...getRowsCols(shape)] as [number, number, number];\n  }\n  return shapeAs3D;\n}\n\nexport function getTextureShapeFromLogicalShape(\n    logShape: number[], isPacked = false): [number, number] {\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n\n    // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n    logShape = logShape.map(\n        (d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n\n    // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  }\n\n  // If logical shape is 2, we don't squeeze, since we want to match physical.\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  let size = util.sizeFromShape(logShape);\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    return [1, size];\n  } else if (\n      logShape.length === 2 && logShape[0] <= maxTexSize &&\n      logShape[1] <= maxTexSize) {\n    return logShape as [number, number];\n  } else if (\n      logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n      logShape[2] <= maxTexSize) {\n    return [logShape[0] * logShape[1], logShape[2]];\n  } else if (\n      logShape.length === 3 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2]];\n  } else if (\n      logShape.length === 4 &&\n      logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n      logShape[3] <= maxTexSize) {\n    return [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (\n      logShape.length === 4 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    return [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  } else {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n\n      const batchDim = getBatchDim(logShape);\n      let rows = 2, cols = 2;\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n      size = batchDim * (rows / 2) * (cols / 2);\n      return util.sizeToSquarishShape(size).map(d => d * 2) as [number, number];\n    }\n    return util.sizeToSquarishShape(size);\n  }\n}\n\nfunction isEven(n: number): boolean {\n  return n % 2 === 0;\n}\n\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1: number[], shape2: number[]): boolean {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {  // One of the shapes is a scalar.\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n      shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {  // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) &&\n        (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE: number;\nlet MAX_TEXTURES_IN_SHADER: number;\n\nexport function getWebGLMaxTextureSize(webGLVersion: number): number {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n  return MAX_TEXTURE_SIZE;\n}\n\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\n\nexport function getMaxTexturesInShader(webGLVersion: number): number {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  }\n  // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\n\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion: number):\n    number {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  let queryTimerVersion: number;\n  const gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n      webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n  return queryTimerVersion;\n}\n\nexport function hasExtension(gl: WebGLRenderingContext, extensionName: string) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\n\nexport function isWebGLVersionEnabled(webGLVersion: 1|2) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n  return false;\n}\n\nexport function isCapableOfRenderingToFloatTexture(webGLVersion: number):\n    boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion: number): boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension =\n          gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(\n          gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl: WebGLRenderingContext):\n    boolean {\n  const texConfig = getTextureConfig(gl);\n\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension: any): boolean {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion: number) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n\n  // tslint:disable-next-line:no-any\n  const isEnabled = (gl as any).fenceSync != null;\n  return isEnabled;\n}\n\nexport function assertNotComplex(\n    tensor: TensorInfo|TensorInfo[], opName: string): void {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(\n          t.dtype !== 'complex64',\n          () => `${opName} does not support complex64 tensors ` +\n              'in the WebGL backend.');\n    }\n  });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}