{"ast":null,"code":"var _s = $RefreshSig$();\n//facial-rec.js\nimport { useEffect, useState, useRef } from 'react';\nimport * as faceLandmarksDetection from '@tensorflow-models/face-landmarks-detection';\nimport '@tensorflow/tfjs-backend-webgl';\nexport const useFaceDetector = videoRef => {\n  _s();\n  const [detector, setDetector] = useState(null);\n  const detectionInterval = useRef(null);\n  const audioRef = useRef(new Audio('/ringtone-126505.mp3'));\n  const [shouldPlayAudio, setShouldPlayAudio] = useState(false);\n  useEffect(() => {\n    const loadModel = async () => {\n      const model = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;\n      const detectorConfig = {\n        runtime: 'tfjs',\n        solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh'\n      };\n      const detector = await faceLandmarksDetection.createDetector(model, detectorConfig);\n      setDetector(detector);\n    };\n    loadModel();\n  }, []);\n  const checkFaces = async () => {\n    if (videoRef.current && !videoRef.current.paused && !videoRef.current.ended && detector) {\n      const faces = await detector.estimateFaces(videoRef.current, {\n        flipHorizontal: false\n      });\n      try {\n        var _faceNames$filter$, _faceNames$filter$2, _faceNames$filter$3, _faceNames$filter$4;\n        const faceNames = faces[0]['keypoints'].filter(items => items.hasOwnProperty('name'));\n        const rightEye = (_faceNames$filter$ = faceNames.filter(items => items[\"name\"] == \"rightEye\")[2]) === null || _faceNames$filter$ === void 0 ? void 0 : _faceNames$filter$.x;\n        const leftEye = (_faceNames$filter$2 = faceNames.filter(items => items[\"name\"] == \"leftEye\")[2]) === null || _faceNames$filter$2 === void 0 ? void 0 : _faceNames$filter$2.x;\n        const faceOvalRight = (_faceNames$filter$3 = faceNames.filter(items => items[\"name\"] == \"faceOval\")[26]) === null || _faceNames$filter$3 === void 0 ? void 0 : _faceNames$filter$3.x;\n        const faceOvalLeft = (_faceNames$filter$4 = faceNames.filter(items => items[\"name\"] == \"faceOval\")[15]) === null || _faceNames$filter$4 === void 0 ? void 0 : _faceNames$filter$4.x;\n        if (rightEye + 50 > faceOvalRight || leftEye - 50 < faceOvalLeft) {\n          if (!shouldPlayAudio) {\n            setShouldPlayAudio(true);\n            audioRef.current.play();\n            console.log(\"Condition met, playing sound.\");\n            updateInterval(1000); // Update interval to 1 second when condition is met\n          }\n        } else {\n          if (shouldPlayAudio) {\n            setShouldPlayAudio(false);\n            audioRef.current.pause();\n            audioRef.current.currentTime = 0;\n            console.log(\"Condition not met, stopping sound.\");\n            updateInterval(30000); // Reset interval to 30 seconds when condition is not met\n          }\n        }\n      } catch (error) {\n        console.error(\"Error processing facial landmarks:\", error);\n        if (shouldPlayAudio) {\n          setShouldPlayAudio(false);\n          audioRef.current.pause();\n          audioRef.current.currentTime = 0;\n          updateInterval(30000); // Ensure interval is correct after error\n        }\n      }\n    }\n  };\n  const updateInterval = ms => {\n    clearInterval(detectionInterval.current);\n    detectionInterval.current = setInterval(checkFaces, ms);\n  };\n  useEffect(() => {\n    if (detector && videoRef.current) {\n      updateInterval(30000); // Initially set to check every 30 seconds\n    }\n    return () => {\n      if (detectionInterval.current) {\n        clearInterval(detectionInterval.current);\n      }\n      if (audioRef.current) {\n        audioRef.current.pause();\n      }\n    };\n  }, [detector, videoRef, shouldPlayAudio]); // Updated to handle shouldPlayAudio change\n\n  return null;\n};\n_s(useFaceDetector, \"gW+PpcRAzSJd+VF0XhhxgLus79Y=\");","map":{"version":3,"names":["useEffect","useState","useRef","faceLandmarksDetection","useFaceDetector","videoRef","_s","detector","setDetector","detectionInterval","audioRef","Audio","shouldPlayAudio","setShouldPlayAudio","loadModel","model","SupportedModels","MediaPipeFaceMesh","detectorConfig","runtime","solutionPath","createDetector","checkFaces","current","paused","ended","faces","estimateFaces","flipHorizontal","_faceNames$filter$","_faceNames$filter$2","_faceNames$filter$3","_faceNames$filter$4","faceNames","filter","items","hasOwnProperty","rightEye","x","leftEye","faceOvalRight","faceOvalLeft","play","console","log","updateInterval","pause","currentTime","error","ms","clearInterval","setInterval"],"sources":["/Users/sanskarmishra/Hackathon-2024/sera/src/facial-rec.js"],"sourcesContent":["//facial-rec.js\nimport { useEffect, useState, useRef } from 'react';\nimport * as faceLandmarksDetection from '@tensorflow-models/face-landmarks-detection';\nimport '@tensorflow/tfjs-backend-webgl';\n\nexport const useFaceDetector = (videoRef) => {\n    const [detector, setDetector] = useState(null);\n    const detectionInterval = useRef(null);\n    const audioRef = useRef(new Audio('/ringtone-126505.mp3'));\n    const [shouldPlayAudio, setShouldPlayAudio] = useState(false);\n\n    useEffect(() => {\n        const loadModel = async () => {\n            const model = faceLandmarksDetection.SupportedModels.MediaPipeFaceMesh;\n            const detectorConfig = {\n                runtime: 'tfjs',\n                solutionPath: 'https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh',\n            };\n            const detector = await faceLandmarksDetection.createDetector(model, detectorConfig);\n            setDetector(detector);\n        };\n\n        loadModel();\n    }, []);\n\n    const checkFaces = async () => {\n        if (videoRef.current && !videoRef.current.paused && !videoRef.current.ended && detector) {\n            const faces = await detector.estimateFaces(videoRef.current, { flipHorizontal: false });\n\n            try {\n                const faceNames = faces[0]['keypoints'].filter(items => items.hasOwnProperty('name'));\n                const rightEye = faceNames.filter(items => items[\"name\"] == \"rightEye\")[2]?.x;\n                const leftEye = faceNames.filter(items => items[\"name\"] == \"leftEye\")[2]?.x;\n                const faceOvalRight = faceNames.filter(items => items[\"name\"] == \"faceOval\")[26]?.x;\n                const faceOvalLeft = faceNames.filter(items => items[\"name\"] == \"faceOval\")[15]?.x;\n\n                if ((rightEye + 50 > faceOvalRight) || (leftEye - 50 < faceOvalLeft)) {\n                    if (!shouldPlayAudio) {\n                        setShouldPlayAudio(true);\n                        audioRef.current.play();\n                        console.log(\"Condition met, playing sound.\");\n                        updateInterval(1000); // Update interval to 1 second when condition is met\n                    }\n                } else {\n                    if (shouldPlayAudio) {\n                        setShouldPlayAudio(false);\n                        audioRef.current.pause();\n                        audioRef.current.currentTime = 0;\n                        console.log(\"Condition not met, stopping sound.\");\n                        updateInterval(30000); // Reset interval to 30 seconds when condition is not met\n                    }\n                }\n            } catch (error) {\n                console.error(\"Error processing facial landmarks:\", error);\n                if (shouldPlayAudio) {\n                    setShouldPlayAudio(false);\n                    audioRef.current.pause();\n                    audioRef.current.currentTime = 0;\n                    updateInterval(30000); // Ensure interval is correct after error\n                }\n            }\n        }\n    };\n\n    const updateInterval = (ms) => {\n        clearInterval(detectionInterval.current);\n        detectionInterval.current = setInterval(checkFaces, ms);\n    };\n\n    useEffect(() => {\n        if (detector && videoRef.current) {\n            updateInterval(30000); // Initially set to check every 30 seconds\n        }\n\n        return () => {\n            if (detectionInterval.current) {\n                clearInterval(detectionInterval.current);\n            }\n            if (audioRef.current) {\n                audioRef.current.pause();\n            }\n        };\n    }, [detector, videoRef, shouldPlayAudio]); // Updated to handle shouldPlayAudio change\n\n    return null;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}