{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function sparseSegmentReductionImpl(input, inputShape, inputDType, indices, segmentIds, isMean = false, defaultValue = 0) {\n  const numIndices = indices.length;\n  // Flatten the array to two dimensions\n  const inputFlat = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1];\n  // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n  const lastSegmentIdPlusOne = numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n  if (outputRows < 0) {\n    throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n  const outputLength = outputShape.reduce((product, value) => product * value, 1);\n  // Output array is initialized with the value 0 by default.\n  const output = util.getArrayFromDType(inputDType, outputLength);\n  // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n    return [output, outputShape];\n  }\n  if (outputRows <= 0) {\n    throw new Error(backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n  let start = 0,\n    end = 1;\n  // Index from which the output is not initialized.\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      }\n      // We have a new segment here.  Verify that the segment ids are growing.\n      if (outIndex >= nextIndex) {\n        throw new Error(backend_util.getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());\n      }\n    }\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(outIndex, outputRows));\n    }\n    // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(i, indices[i], inputFlat[0]));\n      }\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n    if (end > numIndices) {\n      break;\n    }\n  }\n  // Fill the gap at the end with the default value.\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n  return [output, outputShape];\n}","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/kernels/SparseSegmentReduction_impl.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseSegmentReductionImpl(\n    input: TypedArray, inputShape: number[], inputDType: DataType,\n    indices: TypedArray, segmentIds: TypedArray, isMean = false,\n    defaultValue = 0): [TypedArray, number[]] {\n  const numIndices = indices.length;\n\n  // Flatten the array to two dimensions\n  const inputFlat: number[] = [inputShape[0], input.length / inputShape[0]];\n  const numCol = inputFlat[1];\n  // Note that the current implementation assumes that segmentIds values are\n  // sorted.\n  const lastSegmentIdPlusOne =\n      numIndices > 0 ? segmentIds[numIndices - 1] + 1 : 0;\n  const outputRows = lastSegmentIdPlusOne;\n\n  if (outputRows < 0) {\n    throw new Error(\n        backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  const outputShape = inputShape.slice();\n  outputShape[0] = outputRows;\n\n  const outputLength =\n      outputShape.reduce((product, value) => product * value, 1);\n  // Output array is initialized with the value 0 by default.\n  const output = util.getArrayFromDType(inputDType, outputLength) as TypedArray;\n\n  // Note that we do not initialize the output buffer with a default value, so\n  // we need to explicitly set missing indices to the default value.\n  if (numIndices === 0) {\n    if (outputRows > 0) {\n      output.fill(defaultValue);\n    }\n    return [output, outputShape];\n  }\n\n  if (outputRows <= 0) {\n    throw new Error(\n        backend_util.getSparseSegmentReductionNegativeSegmentIdsErrorMessage());\n  }\n\n  let start = 0, end = 1;\n  // Index from which the output is not initialized.\n  let uninitializedIndex = 0;\n  let outIndex = segmentIds[start];\n\n  while (true) {\n    // We initialize nextIndex to 0 to avoid may be uninitialized warning\n    let nextIndex = 0;\n    if (end < numIndices) {\n      nextIndex = segmentIds[end];\n      if (outIndex === nextIndex) {\n        ++end;\n        continue;\n      }\n      // We have a new segment here.  Verify that the segment ids are growing.\n      if (outIndex >= nextIndex) {\n        throw new Error(backend_util\n            .getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage());\n      }\n    }\n\n    if (outIndex < 0 || outIndex >= outputRows) {\n      throw new Error(\n          backend_util.getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage(\n              outIndex, outputRows));\n    }\n\n    // If there is a gap between two indices, we need to set that gap to the\n    // default value.\n    if (outIndex > uninitializedIndex) {\n      output.fill(defaultValue, uninitializedIndex * numCol, outIndex * numCol);\n    }\n\n    for (let i = start; i < end; ++i) {\n      const index = indices[i];\n      if (index < 0 || index >= inputFlat[0]) {\n        throw new Error(\n            backend_util.getSparseSegmentReductionIndicesOutOfRangeErrorMessage(\n                i, indices[i], inputFlat[0]));\n      }\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] += input[index * numCol + j];\n      }\n    }\n\n    if (isMean) {\n      for (let j = 0; j < numCol; j++) {\n        output[outIndex * numCol + j] /= end - start;\n      }\n    }\n\n    start = end;\n    ++end;\n    uninitializedIndex = outIndex + 1;\n    outIndex = nextIndex;\n    if (end > numIndices) {\n      break;\n    }\n  }\n\n  // Fill the gap at the end with the default value.\n  if (uninitializedIndex < outputRows) {\n    output.fill(defaultValue, uninitializedIndex * numCol, outputRows * numCol);\n  }\n\n  return [output, outputShape];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}