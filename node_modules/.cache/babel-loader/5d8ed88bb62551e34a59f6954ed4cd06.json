{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { isWebGLData, isWebGPUData } from '../types';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  } else if (dtype === 'complex64') {\n    throw new Error(`Cannot construct a complex64 tensor directly. ` + `Please use tf.complex(real, imag).`);\n  }\n  if (isWebGPUData(values) || isWebGLData(values)) {\n    if (dtype !== 'float32' && dtype !== 'int32') {\n      throw new Error(`Creating tensor from GPU data only supports ` + `'float32'|'int32' dtype, while the dtype is ${dtype}.`);\n    }\n    return ENGINE.backend.createTensorFromGPUData(values, shape || inferredShape, dtype);\n  }\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  // Verify that the shape matches the inferred shape.\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` + `${providedSize} values but has ${inferredSize}`);\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` + `(${inferredShape}) does not match the provided ` + `shape (${shape}). `);\n    }\n  }\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}","map":{"version":3,"sources":["../../../../../../tfjs-core/src/ops/tensor_ops_util.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAM,QAAO,WAAW;AAEhC,SAAQ,WAAW,EAAE,YAAY,QAAsD,UAAU;AAEjG,SAAQ,MAAM,EAAE,kCAAkC,EAAE,OAAO,EAAE,UAAU,EAAE,YAAY,EAAE,aAAa,EAAE,YAAY,QAAO,SAAS;AAElI;AACA,OAAM,SAAU,UAAU,CACtB,MAAuC,EAAE,KAAe,EACxD,aAAuB,EAAE,KAAgB,EAAA;EAC3C,IAAI,KAAK,IAAI,IAAI,EAAE;IACjB,KAAK,GAAG,UAAU,CAAC,MAAM,CAAC;GAC3B,MAAM,IAAI,KAAK,KAAK,WAAW,EAAE;IAChC,MAAM,IAAI,KAAK,CACX,gDAAgD,GAChD,oCAAoC,CAAC;EAC1C;EAED,IAAI,YAAY,CAAC,MAAM,CAAC,IAAI,WAAW,CAAC,MAAM,CAAC,EAAE;IAC/C,IAAI,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,OAAO,EAAE;MAC5C,MAAM,IAAI,KAAK,CACX,8CAA8C,GAC9C,+CAA+C,KAAK,GAAG,CAAC;IAC7D;IACD,OAAO,MAAM,CAAC,OAAO,CAAC,uBAAuB,CACzC,MAAM,EAAE,KAAK,IAAI,aAAa,EAAE,KAAK,CAAC;EAC3C;EAED,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,IAC/C,OAAO,MAAM,KAAK,QAAQ,IAAI,OAAO,MAAM,KAAK,SAAS,IACzD,OAAO,MAAM,KAAK,QAAQ,EAAE;IAC9B,MAAM,IAAI,KAAK,CACX,qEAAqE,GACrE,uDAAuD,CAAC;EAC7D;EACD;EACA,IAAI,KAAK,IAAI,IAAI,EAAE;IACjB,kCAAkC,CAAC,KAAK,CAAC;IAEzC,MAAM,YAAY,GAAG,aAAa,CAAC,KAAK,CAAC;IACzC,MAAM,YAAY,GAAG,aAAa,CAAC,aAAa,CAAC;IACjD,MAAM,CACF,YAAY,KAAK,YAAY,EAC7B,MACI,iCAAiC,KAAK,4BAA4B,GAClE,GAAG,YAAY,mBAAmB,YAAY,EAAE,CAAC;IAEzD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE;MAC7C,MAAM,QAAQ,GAAG,aAAa,CAAC,CAAC,CAAC;MACjC,MAAM,iBAAiB,GAAG,CAAC,KAAK,aAAa,CAAC,MAAM,GAAG,CAAC,GACpD,QAAQ,KAAK,aAAa,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,GAC1C,IAAI;MACR,MAAM,CACF,aAAa,CAAC,CAAC,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,iBAAiB,EACnD,MAAM,8CAA8C,GAChD,IAAI,aAAa,gCAAgC,GACjD,UAAU,KAAK,KAAK,CAAC;IAC9B;EACF;EAED,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;IACnD,MAAM,GAAG,CAAC,MAAM,CAAa;EAC9B;EAED,KAAK,GAAG,KAAK,IAAI,aAAa;EAC9B,MAAM,GAAG,KAAK,KAAK,QAAQ,GACvB,YAAY,CAAC,MAAM,EAAE,KAAK,CAAC,GAC3B,OAAO,CAAC,MAAkB,EAAE,EAAE,EAAE,IAAI,CAAa;EACrD,OAAO,MAAM,CAAC,UAAU,CAAC,MAAoB,EAAE,KAAK,EAAE,KAAK,CAAC;AAC9D","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {isWebGLData, isWebGPUData, TensorLike, TypedArray, WebGLData, WebGPUData} from '../types';\nimport {DataType} from '../types';\nimport {assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray} from '../util';\n\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(\n    values: TensorLike|WebGLData|WebGPUData, shape: number[],\n    inferredShape: number[], dtype?: DataType): Tensor {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  } else if (dtype === 'complex64') {\n    throw new Error(\n        `Cannot construct a complex64 tensor directly. ` +\n        `Please use tf.complex(real, imag).`);\n  }\n\n  if (isWebGPUData(values) || isWebGLData(values)) {\n    if (dtype !== 'float32' && dtype !== 'int32') {\n      throw new Error(\n          `Creating tensor from GPU data only supports ` +\n          `'float32'|'int32' dtype, while the dtype is ${dtype}.`);\n    }\n    return ENGINE.backend.createTensorFromGPUData(\n        values, shape || inferredShape, dtype);\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values) &&\n      typeof values !== 'number' && typeof values !== 'boolean' &&\n      typeof values !== 'string') {\n    throw new Error(\n        'values passed to tensor(values) must be a number/boolean/string or ' +\n        'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  // Verify that the shape matches the inferred shape.\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(\n        providedSize === inferredSize,\n        () =>\n            `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ?\n          inferred !== sizeFromShape(shape.slice(i)) :\n          true;\n      assert(\n          inferredShape[i] === shape[i] || !flatDimsDontMatch,\n          () => `Error creating a new Tensor. Inferred shape ` +\n              `(${inferredShape}) does not match the provided ` +\n              `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values] as number[];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ?\n      toTypedArray(values, dtype) :\n      flatten(values as string[], [], true) as string[];\n  return ENGINE.makeTensor(values as TypedArray, shape, dtype);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}