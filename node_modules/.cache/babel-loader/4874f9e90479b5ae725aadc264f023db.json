{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\nimport { cloneTensor, getParamValue, getTensor } from './utils';\nexport const executeOp = (node, tensorMap, context, ops = tfOps) => {\n  switch (node.op) {\n    case 'Const':\n      {\n        return tensorMap[node.name];\n      }\n    case 'PlaceholderWithDefault':\n      const def = getParamValue('default', node, tensorMap, context);\n      return [getTensor(node.name, tensorMap, context) || def];\n    case 'Placeholder':\n      return [getTensor(node.name, tensorMap, context)];\n    case 'Identity':\n    case 'StopGradient':\n    case 'FakeQuantWithMinMaxVars':\n      {\n        // This op is currently ignored.\n        const data = getParamValue('x', node, tensorMap, context);\n        return [cloneTensor(data)];\n      }\n    case 'IdentityN':\n      return getParamValue('x', node, tensorMap, context).map(t => cloneTensor(t));\n    case 'Snapshot':\n      const snapshot = getParamValue('x', node, tensorMap, context);\n      return [cloneTensor(snapshot)];\n    case 'Shape':\n      return [ops.tensor1d(getParamValue('x', node, tensorMap, context).shape, 'int32')];\n    case 'ShapeN':\n      return getParamValue('x', node, tensorMap, context).map(t => ops.tensor1d(t.shape));\n    case 'Size':\n      return [ops.scalar(getParamValue('x', node, tensorMap, context).size, 'int32')];\n    case 'Rank':\n      return [ops.scalar(getParamValue('x', node, tensorMap, context).rank, 'int32')];\n    case 'NoOp':\n      return [ops.scalar(1)];\n    case 'Print':\n      const input = getParamValue('x', node, tensorMap, context);\n      const data = getParamValue('data', node, tensorMap, context);\n      const message = getParamValue('message', node, tensorMap, context);\n      const summarize = getParamValue('summarize', node, tensorMap, context);\n      console.warn('The graph has a tf.print() operation,' + 'usually used for debugging, which slows down performance.');\n      console.log(message);\n      for (let i = 0; i < data.length; i++) {\n        console.log(Array.prototype.slice.call(data[i].dataSync()).slice(0, summarize));\n      }\n      return [input];\n    default:\n      throw TypeError(`Node type ${node.op} is not implemented`);\n  }\n};\nexport const CATEGORY = 'graph';","map":{"version":3,"sources":["../../../../../../../tfjs-converter/src/operations/executors/graph_executor.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor} from '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport * as tfOps from '@tensorflow/tfjs-core/dist/ops/ops_for_converter';\n\nimport {NamedTensorsMap} from '../../data/types';\nimport {ExecutionContext} from '../../executor/execution_context';\nimport {InternalOpExecutor, Node} from '../types';\n\nimport {cloneTensor, getParamValue, getTensor} from './utils';\n\nexport const executeOp: InternalOpExecutor =\n    (node: Node, tensorMap: NamedTensorsMap,\n     context: ExecutionContext, ops = tfOps): Tensor[] => {\n      switch (node.op) {\n        case 'Const': {\n          return tensorMap[node.name];\n        }\n        case 'PlaceholderWithDefault':\n          const def =\n              getParamValue('default', node, tensorMap, context) as Tensor;\n          return [getTensor(node.name, tensorMap, context) || def];\n        case 'Placeholder':\n          return [getTensor(node.name, tensorMap, context)];\n        case 'Identity':\n        case 'StopGradient':\n        case 'FakeQuantWithMinMaxVars': {  // This op is currently ignored.\n          const data = getParamValue('x', node, tensorMap, context) as Tensor;\n          return [cloneTensor(data)];\n        }\n        case 'IdentityN':\n          return (getParamValue('x', node, tensorMap, context) as Tensor[])\n              .map((t: Tensor) => cloneTensor(t));\n        case 'Snapshot':\n          const snapshot =\n              (getParamValue('x', node, tensorMap, context) as Tensor);\n          return [cloneTensor(snapshot)];\n        case 'Shape':\n          return [ops.tensor1d(\n              (getParamValue('x', node, tensorMap, context) as Tensor).shape,\n              'int32')];\n        case 'ShapeN':\n          return (getParamValue('x', node, tensorMap, context) as Tensor[])\n              .map((t: Tensor) => ops.tensor1d(t.shape));\n        case 'Size':\n          return [ops.scalar(\n              (getParamValue('x', node, tensorMap, context) as Tensor).size,\n              'int32')];\n        case 'Rank':\n          return [ops.scalar(\n              (getParamValue('x', node, tensorMap, context) as Tensor).rank,\n              'int32')];\n        case 'NoOp':\n          return [ops.scalar(1)];\n        case 'Print':\n          const input = getParamValue('x', node, tensorMap, context) as Tensor;\n          const data =\n              getParamValue('data', node, tensorMap, context) as Tensor[];\n          const message =\n              getParamValue('message', node, tensorMap, context) as string;\n          const summarize =\n              getParamValue('summarize', node, tensorMap, context) as number;\n          console.warn(\n              'The graph has a tf.print() operation,' +\n              'usually used for debugging, which slows down performance.');\n          console.log(message);\n          for (let i = 0; i < data.length; i++) {\n            console.log(Array.prototype.slice.call(data[i].dataSync())\n                            .slice(0, summarize));\n          }\n          return [input];\n\n        default:\n          throw TypeError(`Node type ${node.op} is not implemented`);\n      }\n    };\n\nexport const CATEGORY = 'graph';\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}