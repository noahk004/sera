{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { BroadcastArgs } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Return the shape of s0 op s1 with broadcast.\n *\n * compute r0, the broadcasted shape as a tensor.\n * s0, s1 and r0 are all integer vectors.\n *\n * This function returns the shape of the result of an operation between\n * two tensors of size s0 and s1 performed with broadcast.\n *\n * @param s0 A tensor representing a shape\n * @param s1 A tensor representing a shape\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction broadcastArgs_(s0, s1) {\n  const shape1Input = convertToTensor(s0, 's0', 'broadcastArgs', 'int32');\n  const shape2Input = convertToTensor(s1, 's1', 'broadcastArgs', 'int32');\n  if (shape1Input.rank !== 1) {\n    throw new Error('broadcastArgs(): first input must be a vector (rank=1). ' + `Has rank ${shape1Input.rank}`);\n  }\n  if (shape2Input.rank !== 1) {\n    throw new Error('broadcastArgs(): second input must be a vector (rank=1). ' + `Has rank ${shape2Input.rank}`);\n  }\n  const inputs = {\n    s0: shape1Input,\n    s1: shape2Input\n  };\n  return ENGINE.runKernel(BroadcastArgs, inputs);\n}\nexport const broadcastArgs = /* @__PURE__ */op({\n  broadcastArgs_\n});","map":{"version":3,"sources":["../../../../../../tfjs-core/src/ops/broadcast_args.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAGH,SAAS,MAAM,QAAQ,WAAW;AAClC,SAAS,aAAa,QAA6B,iBAAiB;AAEpE,SAAS,eAAe,QAAQ,oBAAoB;AAGpD,SAAS,EAAE,QAAQ,aAAa;AAEhC;;;;;;;;;;;;;AAaG;AACH,SAAS,cAAc,CACrB,EAAuB,EAAE,EAAuB,EAAA;EAChD,MAAM,WAAW,GAAG,eAAe,CAAC,EAAE,EAAE,IAAI,EAAE,eAAe,EAAE,OAAO,CAAC;EACvE,MAAM,WAAW,GAAG,eAAe,CAAC,EAAE,EAAE,IAAI,EAAE,eAAe,EAAE,OAAO,CAAC;EAEvE,IAAI,WAAW,CAAC,IAAI,KAAK,CAAC,EAAE;IAC1B,MAAM,IAAI,KAAK,CACb,0DAA0D,GAC1D,YAAY,WAAW,CAAC,IAAI,EAAE,CAAC;EAClC;EAED,IAAI,WAAW,CAAC,IAAI,KAAK,CAAC,EAAE;IAC1B,MAAM,IAAI,KAAK,CACb,2DAA2D,GAC3D,YAAY,WAAW,CAAC,IAAI,EAAE,CAAC;EAClC;EAED,MAAM,MAAM,GAAwB;IAAE,EAAE,EAAE,WAAW;IAAE,EAAE,EAAE;EAAW,CAAE;EACxE,OAAO,MAAM,CAAC,SAAS,CAAC,aAAa,EAAE,MAAmC,CAAC;AAC7E;AAEA,OAAO,MAAM,aAAa,GAAG,eAAgB,EAAE,CAAC;EAAE;AAAc,CAAE,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport { NamedTensorMap } from '../tensor_types';\nimport { ENGINE } from '../engine';\nimport { BroadcastArgs, BroadcastArgsInputs } from '../kernel_names';\nimport { Tensor } from '../tensor';\nimport { convertToTensor } from '../tensor_util_env';\nimport { Rank, TensorLike } from '../types';\n\nimport { op } from './operation';\n\n/**\n * Return the shape of s0 op s1 with broadcast.\n *\n * compute r0, the broadcasted shape as a tensor.\n * s0, s1 and r0 are all integer vectors.\n *\n * This function returns the shape of the result of an operation between\n * two tensors of size s0 and s1 performed with broadcast.\n *\n * @param s0 A tensor representing a shape\n * @param s1 A tensor representing a shape\n *\n * @doc {heading: 'Tensors', subheading: 'Transformations'}\n */\nfunction broadcastArgs_<R extends Rank>(\n  s0: Tensor | TensorLike, s1: Tensor | TensorLike): Tensor<R> {\n  const shape1Input = convertToTensor(s0, 's0', 'broadcastArgs', 'int32');\n  const shape2Input = convertToTensor(s1, 's1', 'broadcastArgs', 'int32');\n\n  if (shape1Input.rank !== 1) {\n    throw new Error(\n      'broadcastArgs(): first input must be a vector (rank=1). ' +\n      `Has rank ${shape1Input.rank}`);\n  }\n\n  if (shape2Input.rank !== 1) {\n    throw new Error(\n      'broadcastArgs(): second input must be a vector (rank=1). ' +\n      `Has rank ${shape2Input.rank}`);\n  }\n\n  const inputs: BroadcastArgsInputs = { s0: shape1Input, s1: shape2Input };\n  return ENGINE.runKernel(BroadcastArgs, inputs as unknown as NamedTensorMap);\n}\n\nexport const broadcastArgs = /* @__PURE__ */ op({ broadcastArgs_ });\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}