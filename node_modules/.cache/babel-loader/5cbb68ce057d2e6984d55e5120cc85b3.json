{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { getChannels } from './packing_util';\nimport { getCoordsDataType } from './shader_compiler';\nexport class ReversePackedProgram {\n  constructor(xShape, axis) {\n    this.variableNames = ['x'];\n    this.packedInputs = true;\n    this.packedOutput = true;\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(`WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n    const channels = getChannels('rc', rank);\n    const nextColumn = `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n    const type = getCoordsDataType(rank);\n    if (rank === 1) {\n      this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n    } else {\n      this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n    }\n    function getR(channels) {\n      return getChannel(channels);\n    }\n    function getG(channels) {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      return getChannel(channels);\n    }\n    function getB(channels) {\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n    function getA(channels) {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n    function getChannel(channels) {\n      const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n      const inCoords = inCoordsArray.join(',');\n      const innerDims = inCoordsArray.slice(-2).join(',');\n      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n    }\n    function getInCoord(i, channels1) {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - ${channels1[i]} - 1`;\n      } else {\n        return `${channels1[i]}`;\n      }\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../tfjs-backend-webgl/src/reverse_packed_gpu.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {GPGPUProgram} from './gpgpu_math';\nimport {getChannels} from './packing_util';\nimport {getCoordsDataType} from './shader_compiler';\n\nexport class ReversePackedProgram implements GPGPUProgram {\n  variableNames = ['x'];\n  outputShape: number[];\n  userCode: string;\n  packedInputs = true;\n  packedOutput = true;\n\n  constructor(xShape: number[], axis: number[]) {\n    const rank = xShape.length;\n    if (rank > 4) {\n      throw new Error(\n          `WebGL backend: Reverse of rank-${rank} tensor is not yet supported`);\n    }\n    this.outputShape = xShape;\n    const channels = getChannels('rc', rank);\n    const nextColumn =\n        `${channels[rank - 1]} + 1 < ${this.outputShape[rank - 1]}`;\n    const nextRow = `${channels[rank - 2]} + 1 < ${this.outputShape[rank - 2]}`;\n    const type = getCoordsDataType(rank);\n    if (rank === 1) {\n      this.userCode = `\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(${xShape[0]} - rc - 1),\n            ${xShape[0]} - rc - 1);\n          if(${nextColumn}){\n              result.g = getChannel(getX(${xShape[0]} - (rc  + 1) - 1),\n                ${xShape[0]} - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      `;\n    } else {\n      this.userCode = `\n        void main() {\n          ${type} rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ${getR(channels.slice())};\n          if(${nextColumn}){\n            result.g = ${getG(channels.slice())};\n          }\n          if(${nextRow}) {\n            result.b = ${getB(channels.slice())};\n            if(${nextColumn}) {\n              result.a = ${getA(channels.slice())};\n            }\n          }\n          setOutput(result);\n        }\n    `;\n    }\n\n    function getR(channels: string[]): string {\n      return getChannel(channels);\n    }\n\n    function getG(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getB(channels: string[]): string {\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getA(channels: string[]): string {\n      channels[rank - 1] = '(' + channels[rank - 1] + ` + 1)`;\n      channels[rank - 2] = '(' + channels[rank - 2] + ` + 1)`;\n      return getChannel(channels);\n    }\n\n    function getChannel(channels: string[]): string {\n      const inCoordsArray = xShape.map((_, i) => getInCoord(i, channels));\n      const inCoords = inCoordsArray.join(',');\n      const innerDims = inCoordsArray.slice(-2).join(',');\n      return `getChannel(getX(${inCoords}), vec2(${innerDims}))`;\n    }\n\n    function getInCoord(i: number, channels1: string[]): string {\n      if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {\n        return `${xShape[i]} - ${channels1[i]} - 1`;\n      } else {\n        return `${channels1[i]}`;\n      }\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}