{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { RaggedGather } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\nfunction raggedGather_(paramsNestedSplits, paramsDenseValues, indices, outputRaggedRank) {\n  const $paramsNestedSplits = paramsNestedSplits.map((t, i) => convertToTensor(t, `tensors${i}`, 'raggedGather', 'int32'));\n  const $paramsDenseValues = convertToTensor(paramsDenseValues, 'paramsDenseValues', 'raggedGather');\n  const $indices = convertToTensor(indices, 'indices', 'raggedGather', 'int32');\n  const inputs = {\n    paramsNestedSplits: $paramsNestedSplits,\n    paramsDenseValues: $paramsDenseValues,\n    indices: $indices\n  };\n  const attrs = {\n    outputRaggedRank\n  };\n  const result = ENGINE.runKernel(RaggedGather, inputs, attrs);\n  return {\n    outputNestedSplits: result.slice(0, result.length - 1),\n    outputDenseValues: result[result.length - 1]\n  };\n}\nexport const raggedGather = /* @__PURE__ */op({\n  raggedGather_\n});","map":{"version":3,"sources":["../../../../../../tfjs-core/src/ops/ragged_gather.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAM,QAAO,WAAW;AAChC,SAAQ,YAAY,QAA8C,iBAAiB;AAEnF,SAAQ,eAAe,QAAO,oBAAoB;AAElD,SAAQ,EAAE,QAAO,aAAa;AA4B9B,SAAS,aAAa,CAClB,kBAA4B,EAAE,iBAAoC,EAClE,OAA0B,EAAE,gBAAwB,EAAA;EACtD,MAAM,mBAAmB,GAAG,kBAAkB,CAAC,GAAG,CAC9C,CAAC,CAAC,EAAE,CAAC,KAAK,eAAe,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE,EAAE,cAAc,EAAE,OAAO,CAAC,CAAC;EACzE,MAAM,kBAAkB,GACpB,eAAe,CAAC,iBAAiB,EAAE,mBAAmB,EAAE,cAAc,CAAC;EAC3E,MAAM,QAAQ,GAAG,eAAe,CAAC,OAAO,EAAE,SAAS,EAAE,cAAc,EAAE,OAAO,CAAC;EAE7E,MAAM,MAAM,GAAuB;IACjC,kBAAkB,EAAE,mBAAmB;IACvC,iBAAiB,EAAE,kBAAkB;IACrC,OAAO,EAAE;GACV;EACD,MAAM,KAAK,GAAsB;IAAC;EAAgB,CAAC;EAEnD,MAAM,MAAM,GACR,MAAM,CAAC,SAAS,CAAC,YAAY,EAAE,MAAY,EAAE,KAAW,CAAC;EAC7D,OAAO;IACL,kBAAkB,EAAE,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC;IACtD,iBAAiB,EAAE,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC;GAC5C;AACH;AAEA,OAAO,MAAM,YAAY,GAAG,eAAgB,EAAE,CAAC;EAAC;AAAa,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {RaggedGather, RaggedGatherAttrs, RaggedGatherInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * Gather ragged slices from params axis 0 according to indices.\n *\n * @param paramsNestedSplits: A list of at least 1 Tensor with type 'int32' The\n *     nestedRowSplits tensors that define the row-partitioning for the params\n *     RaggedTensor input.\n * @param paramsDenseValues: A Tensor. The flatValues for the params\n *     RaggedTensor.\n * @param indices: A Tensor. Must be one of type: int32. Indices in the\n *     outermost dimension of params of the values that should be gathered.\n * @param outputRaggedRank: An int that is >= 0. The ragged rank of the output\n *     RaggedTensor. outputNestedSplits will contain this number of rowSplits\n *     tensors. This value should equal indices.shape.ndims + params.raggedRank\n *     - 1.\n * @return A map with the following properties:\n *     - outputNestedSplits: A list of outputRaggedRank Tensor objects with the\n * same type as paramsNestedSplits.\n *     - outputDenseValues: A Tensor. Has the same type as paramsDenseValues.\n * @doc {heading: 'Operations', subheading: 'Ragged'}\n */\n\ninterface RaggedGatherMap {\n  outputNestedSplits: Tensor[];\n  outputDenseValues: Tensor;\n}\n\nfunction raggedGather_(\n    paramsNestedSplits: Tensor[], paramsDenseValues: Tensor|TensorLike,\n    indices: Tensor|TensorLike, outputRaggedRank: number): RaggedGatherMap {\n  const $paramsNestedSplits = paramsNestedSplits.map(\n      (t, i) => convertToTensor(t, `tensors${i}`, 'raggedGather', 'int32'));\n  const $paramsDenseValues =\n      convertToTensor(paramsDenseValues, 'paramsDenseValues', 'raggedGather');\n  const $indices = convertToTensor(indices, 'indices', 'raggedGather', 'int32');\n\n  const inputs: RaggedGatherInputs = {\n    paramsNestedSplits: $paramsNestedSplits,\n    paramsDenseValues: $paramsDenseValues,\n    indices: $indices,\n  };\n  const attrs: RaggedGatherAttrs = {outputRaggedRank};\n\n  const result: Tensor[] =\n      ENGINE.runKernel(RaggedGather, inputs as {}, attrs as {});\n  return {\n    outputNestedSplits: result.slice(0, result.length - 1),\n    outputDenseValues: result[result.length - 1],\n  };\n}\n\nexport const raggedGather = /* @__PURE__ */ op({raggedGather_});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}