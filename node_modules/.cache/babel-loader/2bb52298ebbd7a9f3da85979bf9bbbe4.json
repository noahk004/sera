{"ast":null,"code":"/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { parseNodeName } from '../operations/executors/utils';\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(inputs, outputs, weightMap, initNodes) {\n  const usedNodes = new Set();\n  const missingInputs = [];\n  let dynamicNode = null;\n  let syncInputs = null;\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  const seen = new Set();\n  const inputNodeNames = new Set(Object.keys(inputs).map(name => parseNodeName(name)[0]));\n  initNodes = initNodes || [];\n  const initNodeNames = new Set(initNodes.map(node => parseNodeName(node.name)[0]));\n  const frontier = [...outputs];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name).filter(name => usedNodes.has(name));\n      }\n    }\n    usedNodes.add(node.name);\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.has(node.name)) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.has(node.name)) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {\n    inputs,\n    outputs,\n    usedNodes,\n    missingInputs,\n    dynamicNode,\n    syncInputs\n  };\n}\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(graph, executionInfo) {\n  const {\n    usedNodes,\n    inputs\n  } = executionInfo;\n  const inputNodes = Object.keys(inputs).map(name => parseNodeName(name)[0]).map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes || [];\n  const isUsed = node => usedNodes.has(typeof node === 'string' ? node : node.name);\n  function unique(nodes) {\n    return [...new Map(nodes.map(node => [node.name, node])).values()];\n  }\n  const predefinedNodes = unique([...inputNodes, ...graph.weights, ...initNodes]).filter(isUsed);\n  const allNodes = unique([...predefinedNodes, ...Object.values(graph.nodes)]).filter(isUsed);\n  const nameToNode = new Map(allNodes.map(node => [node.name, node]));\n  const inCounts = {};\n  for (const node of allNodes) {\n    inCounts[node.name] = inCounts[node.name] || 0;\n    for (const child of node.children) {\n      // When the child is unused, set in counts to infinity so that it will\n      // never be decreased to 0 and added to the execution list.\n      if (!isUsed(child)) {\n        inCounts[child.name] = Number.POSITIVE_INFINITY;\n      }\n      inCounts[child.name] = (inCounts[child.name] || 0) + 1;\n    }\n  }\n  // Build execution order for all used nodes regardless whether they are\n  // predefined or not.\n  const frontier = Object.entries(inCounts).filter(([, inCount]) => inCount === 0).map(([name]) => name);\n  const orderedNodeNames = [...frontier];\n  while (frontier.length > 0) {\n    const nodeName = frontier.pop();\n    const node = nameToNode.get(nodeName);\n    for (const child of node.children.filter(isUsed)) {\n      if (--inCounts[child.name] === 0) {\n        orderedNodeNames.push(child.name);\n        frontier.push(child.name);\n      }\n    }\n  }\n  const orderedNodes = orderedNodeNames.map(name => nameToNode.get(name));\n  const filteredOrderedNodes = filterPredefinedReachableNodes(orderedNodes, predefinedNodes);\n  // TODO: Turn validation on/off with tf env flag.\n  validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);\n  return filteredOrderedNodes;\n}\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Returns ordered nodes reachable by at least one predefined node.\n * This can help us filter out redundant nodes from the returned node list.\n * For example:\n * If we have four nodes with dependencies like this:\n *   a --> b --> c --> d\n * when node `c` is predefined (e.g. given as an input tensor), we can\n * skip node `a` and `b` since their outputs will never be used.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction filterPredefinedReachableNodes(orderedNodes, predefinedNodes) {\n  const nameToNode = new Map(orderedNodes.map(node => [node.name, node]));\n  // TODO: Filter out more nodes when >=2 nodes are predefined in a path.\n  const stack = predefinedNodes.map(node => node.name);\n  const predefinedReachableNodeNames = new Set(stack);\n  // Perform a DFS starting from the set of all predefined nodes\n  // to find the set of all nodes reachable from the predefined nodes.\n  while (stack.length > 0) {\n    const nodeName = stack.pop();\n    const node = nameToNode.get(nodeName);\n    for (const child of node.children) {\n      if (!nameToNode.has(child.name) || predefinedReachableNodeNames.has(child.name)) {\n        continue;\n      }\n      predefinedReachableNodeNames.add(child.name);\n      stack.push(child.name);\n    }\n  }\n  // Filter out unreachable nodes and build the ordered node list.\n  const filteredOrderedNodes = orderedNodes.filter(node => predefinedReachableNodeNames.has(node.name));\n  return filteredOrderedNodes;\n}\nclass NodesExecutionOrderError extends Error {\n  constructor(message) {\n    super(`NodesExecutionOrderError: ${message}`);\n  }\n}\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Validates property: given nodes `a` and `b`, Order(a) > Order(b) if `a`\n * is a child of `b`. This function throws an error if validation fails.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction validateNodesExecutionOrder(orderedNodes, predefinedNodes) {\n  const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));\n  const predefinedNodeNames = new Set(predefinedNodes.map(node => node.name));\n  const isPredefined = node => predefinedNodeNames.has(typeof node === 'string' ? node : node.name);\n  const willBeExecutedNodeNames = new Set(orderedNodes.map(node => node.name));\n  const willBeExecuted = node => willBeExecutedNodeNames.has(typeof node === 'string' ? node : node.name);\n  for (const node of orderedNodes) {\n    for (const child of node.children.filter(willBeExecuted)) {\n      if (!nodeNameToOrder.has(child.name)) {\n        throw new NodesExecutionOrderError(`Child ${child.name} of node ${node.name} is unreachable.`);\n      }\n      if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {\n        throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run after its child ${child.name}.`);\n      }\n    }\n    if (!isPredefined(node)) {\n      for (const input of node.inputs) {\n        if (!nodeNameToOrder.has(input.name)) {\n          throw new NodesExecutionOrderError(`Input ${input.name} of node ${node.name} is unreachable.`);\n        }\n        if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {\n          throw new NodesExecutionOrderError(`Node ${node.name} is scheduled to run before its input ${input.name}.`);\n        }\n      }\n    }\n  }\n}\n/**\n * Given the execution info, return a map from node name to the disposable\n * node name list after its execution.\n *\n * @returns A map from node name to disposable nodes after its\n *     execution. That is, for a node `x`, `nodeLiveUntilMap[x]` indicates\n *     all nodes which their intermediate tensors should be disposed after `x`\n *     being executed.\n */\nexport function getNodeLiveUntilMap(orderedNodes) {\n  const nodeNameToOrder = new Map(orderedNodes.map((node, order) => [node.name, order]));\n  const INF_LIFE = Number.MAX_SAFE_INTEGER;\n  // Make control flow nodes (and consequently their direct parents)\n  // live forever since they're tricky to track correctly.\n  const selfLifespans = orderedNodes.map((node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);\n  const getSelfLifeSpan = node => {\n    const selfLife = selfLifespans[nodeNameToOrder.get(node.name)];\n    if (selfLife == null) {\n      // If nodeToOrder does not contain the node, it is unused or\n      // unreachable in graph.\n      return -1;\n    }\n    return selfLife;\n  };\n  // `liveUntil[i]` points to the last node in the `orderedNodes` array that\n  // may depend on tensors from node `i`. It indicates that all the\n  // intermediate tensors from `orderedNodes[i]` should be disposed after\n  // `orderedNodes[liveUntil[i]]` is executed.\n  // A node lives long enough to pass on its tensors to its children.\n  // It lives until at least `max(node's position, children's positions)`.\n  const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {\n    return node.children.map(getSelfLifeSpan).reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);\n  });\n  // liveUntilMap:\n  // - Key: Name of a node `x`\n  // - Values: All nodes whose intermediate tensors should be disposed\n  //           after `x` is executed.\n  const liveUntilMap = new Map();\n  for (let nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {\n    const liveUntilOrder = liveUntilOrders[nodeOrder];\n    if (liveUntilOrder === INF_LIFE) {\n      continue;\n    }\n    const node = orderedNodes[nodeOrder];\n    const liveUntilNode = orderedNodes[liveUntilOrder];\n    if (!liveUntilMap.has(liveUntilNode.name)) {\n      liveUntilMap.set(liveUntilNode.name, []);\n    }\n    liveUntilMap.get(liveUntilNode.name).push(node);\n  }\n  return liveUntilMap;\n}\nconst CONTROL_FLOW_OPS = new Set(['Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf', 'StatelessWhile', 'if', 'While']);\nconst DYNAMIC_SHAPE_OPS = new Set(['NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where']);\nconst HASH_TABLE_OPS = new Set(['HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2', 'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2']);\nexport function isControlFlow(node) {\n  return CONTROL_FLOW_OPS.has(node.op);\n}\nexport function isDynamicShape(node) {\n  return DYNAMIC_SHAPE_OPS.has(node.op);\n}\nexport function isHashTable(node) {\n  return HASH_TABLE_OPS.has(node.op);\n}","map":{"version":3,"sources":["../../../../../../tfjs-converter/src/executor/model_analysis.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {NamedTensorMap} from '@tensorflow/tfjs-core';\n\nimport {NamedTensorsMap} from '../data/types';\nimport {parseNodeName} from '../operations/executors/utils';\nimport {Graph, Node} from '../operations/types';\n\nexport interface ExecutionInfo {\n  inputs: NamedTensorMap;\n  outputs: Node[];\n  usedNodes: Set<string>;\n  missingInputs: string[];\n  dynamicNode: Node;\n  syncInputs: string[];\n}\n\n/**\n * Given graph inputs and desired outputs, find the minimal set of nodes\n * to execute in order to compute the outputs. In addition return other useful\n * info such:\n * - Missing inputs needed to compute the output.\n * - Whether the subgraph contains dynamic ops (control flow, dynamic shape).\n * - Alternative inputs in order to avoid async (dynamic op) execution.\n */\nexport function getExecutionSubgraph(\n    inputs: NamedTensorMap, outputs: Node[], weightMap: NamedTensorsMap,\n    initNodes?: Node[]): ExecutionInfo {\n  const usedNodes = new Set<string>();\n  const missingInputs: string[] = [];\n  let dynamicNode: Node = null;\n  let syncInputs: string[] = null;\n\n  // Start with the outputs, going backwards and find all the nodes that are\n  // needed to compute those outputs.\n  const seen = new Set<string>();\n  const inputNodeNames =\n      new Set(Object.keys(inputs).map((name) => parseNodeName(name)[0]));\n\n  initNodes = initNodes || [];\n  const initNodeNames =\n      new Set(initNodes.map((node) => parseNodeName(node.name)[0]));\n\n  const frontier = [...outputs];\n  while (frontier.length > 0) {\n    const node = frontier.pop();\n    if (isControlFlow(node) || isDynamicShape(node) || isHashTable(node)) {\n      if (dynamicNode == null) {\n        dynamicNode = node;\n        syncInputs = dynamicNode.children.map(child => child.name)\n                         .filter(name => usedNodes.has(name));\n      }\n    }\n    usedNodes.add(node.name);\n\n    // Weights are dead end since we already have their values.\n    if (weightMap[node.name] != null) {\n      continue;\n    }\n    // This node is a dead end since it's one of the user-provided inputs.\n    if (inputNodeNames.has(node.name)) {\n      continue;\n    }\n    // This node is a dead end since it doesn't have any inputs.\n    if (initNodeNames.has(node.name)) {\n      continue;\n    }\n    if (node.inputs.length === 0) {\n      missingInputs.push(node.name);\n      continue;\n    }\n    node.inputs.forEach(input => {\n      // Don't add to the frontier if it is already there.\n      if (seen.has(input.name)) {\n        return;\n      }\n      seen.add(input.name);\n      frontier.push(input);\n    });\n  }\n  return {inputs, outputs, usedNodes, missingInputs, dynamicNode, syncInputs};\n}\n\n/**\n * Given the execution info, return a list of nodes in topological order that\n * need to be executed to compute the output.\n */\nexport function getNodesInTopologicalOrder(\n    graph: Graph, executionInfo: ExecutionInfo): Node[] {\n  const {usedNodes, inputs} = executionInfo;\n  const inputNodes = Object.keys(inputs)\n                         .map(name => parseNodeName(name)[0])\n                         .map(name => graph.nodes[name]);\n  const initNodes = graph.initNodes || [];\n\n  const isUsed = (node: Node|string) =>\n      usedNodes.has(typeof node === 'string' ? node : node.name);\n\n  function unique(nodes: Node[]): Node[] {\n    return [...new Map(nodes.map((node) => [node.name, node])).values()];\n  }\n  const predefinedNodes = unique([\n                            ...inputNodes,\n                            ...graph.weights,\n                            ...initNodes,\n                          ]).filter(isUsed);\n  const allNodes = unique([\n                     ...predefinedNodes,\n                     ...Object.values(graph.nodes),\n                   ]).filter(isUsed);\n  const nameToNode =\n      new Map<string, Node>(allNodes.map((node) => [node.name, node]));\n\n  const inCounts: Record<string, number> = {};\n  for (const node of allNodes) {\n    inCounts[node.name] = inCounts[node.name] || 0;\n    for (const child of node.children) {\n      // When the child is unused, set in counts to infinity so that it will\n      // never be decreased to 0 and added to the execution list.\n      if (!isUsed(child)) {\n        inCounts[child.name] = Number.POSITIVE_INFINITY;\n      }\n      inCounts[child.name] = (inCounts[child.name] || 0) + 1;\n    }\n  }\n\n  // Build execution order for all used nodes regardless whether they are\n  // predefined or not.\n  const frontier = Object.entries(inCounts)\n                       .filter(([, inCount]) => inCount === 0)\n                       .map(([name]) => name);\n  const orderedNodeNames = [...frontier];\n  while (frontier.length > 0) {\n    const nodeName = frontier.pop();\n    const node = nameToNode.get(nodeName)!;\n    for (const child of node.children.filter(isUsed)) {\n      if (--inCounts[child.name] === 0) {\n        orderedNodeNames.push(child.name);\n        frontier.push(child.name);\n      }\n    }\n  }\n\n  const orderedNodes = orderedNodeNames.map((name) => nameToNode.get(name));\n  const filteredOrderedNodes =\n      filterPredefinedReachableNodes(orderedNodes, predefinedNodes);\n\n  // TODO: Turn validation on/off with tf env flag.\n  validateNodesExecutionOrder(filteredOrderedNodes, predefinedNodes);\n\n  return filteredOrderedNodes;\n}\n\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Returns ordered nodes reachable by at least one predefined node.\n * This can help us filter out redundant nodes from the returned node list.\n * For example:\n * If we have four nodes with dependencies like this:\n *   a --> b --> c --> d\n * when node `c` is predefined (e.g. given as an input tensor), we can\n * skip node `a` and `b` since their outputs will never be used.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction filterPredefinedReachableNodes(\n    orderedNodes: Node[], predefinedNodes: Node[]) {\n  const nameToNode =\n      new Map<string, Node>(orderedNodes.map((node) => [node.name, node]));\n\n  // TODO: Filter out more nodes when >=2 nodes are predefined in a path.\n  const stack = predefinedNodes.map((node) => node.name);\n  const predefinedReachableNodeNames = new Set(stack);\n  // Perform a DFS starting from the set of all predefined nodes\n  // to find the set of all nodes reachable from the predefined nodes.\n  while (stack.length > 0) {\n    const nodeName = stack.pop();\n    const node = nameToNode.get(nodeName)!;\n    for (const child of node.children) {\n      if (!nameToNode.has(child.name) ||\n          predefinedReachableNodeNames.has(child.name)) {\n        continue;\n      }\n      predefinedReachableNodeNames.add(child.name);\n      stack.push(child.name);\n    }\n  }\n\n  // Filter out unreachable nodes and build the ordered node list.\n  const filteredOrderedNodes = orderedNodes.filter(\n      (node) => predefinedReachableNodeNames.has(node.name));\n\n  return filteredOrderedNodes;\n}\n\nclass NodesExecutionOrderError extends Error {\n  constructor(message: string) {\n    super(`NodesExecutionOrderError: ${message}`);\n  }\n}\n\n/**\n * This is a helper function of `getNodesInTopologicalOrder`.\n * Validates property: given nodes `a` and `b`, Order(a) > Order(b) if `a`\n * is a child of `b`. This function throws an error if validation fails.\n *\n * @param orderedNodes Graph nodes in execution order.\n * @param predefinedNodes Graph inputs, weights, and init nodes. Nodes in this\n *     list must have distinct names.\n */\nfunction validateNodesExecutionOrder(\n    orderedNodes: Node[], predefinedNodes: Node[]) {\n  const nodeNameToOrder = new Map<string, number>(\n      orderedNodes.map((node, order) => [node.name, order]));\n  const predefinedNodeNames = new Set(predefinedNodes.map((node) => node.name));\n  const isPredefined = (node: Node|string) =>\n      predefinedNodeNames.has(typeof node === 'string' ? node : node.name);\n  const willBeExecutedNodeNames =\n      new Set(orderedNodes.map((node) => node.name));\n  const willBeExecuted = (node: Node|string) =>\n      willBeExecutedNodeNames.has(typeof node === 'string' ? node : node.name);\n\n  for (const node of orderedNodes) {\n    for (const child of node.children.filter(willBeExecuted)) {\n      if (!nodeNameToOrder.has(child.name)) {\n        throw new NodesExecutionOrderError(\n            `Child ${child.name} of node ${node.name} is unreachable.`);\n      }\n      if (nodeNameToOrder.get(node.name) > nodeNameToOrder.get(child.name)) {\n        throw new NodesExecutionOrderError(`Node ${\n            node.name} is scheduled to run after its child ${child.name}.`);\n      }\n    }\n    if (!isPredefined(node)) {\n      for (const input of node.inputs) {\n        if (!nodeNameToOrder.has(input.name)) {\n          throw new NodesExecutionOrderError(\n              `Input ${input.name} of node ${node.name} is unreachable.`);\n        }\n        if (nodeNameToOrder.get(input.name) > nodeNameToOrder.get(node.name)) {\n          throw new NodesExecutionOrderError(`Node ${\n              node.name} is scheduled to run before its input ${input.name}.`);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Given the execution info, return a map from node name to the disposable\n * node name list after its execution.\n *\n * @returns A map from node name to disposable nodes after its\n *     execution. That is, for a node `x`, `nodeLiveUntilMap[x]` indicates\n *     all nodes which their intermediate tensors should be disposed after `x`\n *     being executed.\n */\nexport function getNodeLiveUntilMap(orderedNodes: Node[]): Map<string, Node[]> {\n  const nodeNameToOrder = new Map<string, number>(\n      orderedNodes.map((node, order) => [node.name, order]));\n\n  const INF_LIFE = Number.MAX_SAFE_INTEGER;\n  // Make control flow nodes (and consequently their direct parents)\n  // live forever since they're tricky to track correctly.\n  const selfLifespans = orderedNodes.map(\n      (node, nodeOrder) => isControlFlow(node) ? INF_LIFE : nodeOrder);\n  const getSelfLifeSpan = (node: Node) => {\n    const selfLife = selfLifespans[nodeNameToOrder.get(node.name)!];\n    if (selfLife == null) {\n      // If nodeToOrder does not contain the node, it is unused or\n      // unreachable in graph.\n      return -1;\n    }\n    return selfLife;\n  };\n\n  // `liveUntil[i]` points to the last node in the `orderedNodes` array that\n  // may depend on tensors from node `i`. It indicates that all the\n  // intermediate tensors from `orderedNodes[i]` should be disposed after\n  // `orderedNodes[liveUntil[i]]` is executed.\n  // A node lives long enough to pass on its tensors to its children.\n  // It lives until at least `max(node's position, children's positions)`.\n  const liveUntilOrders = orderedNodes.map((node, nodeOrder) => {\n    return node.children.map(getSelfLifeSpan)\n        .reduce((a, b) => Math.max(a, b), selfLifespans[nodeOrder]);\n  });\n\n  // liveUntilMap:\n  // - Key: Name of a node `x`\n  // - Values: All nodes whose intermediate tensors should be disposed\n  //           after `x` is executed.\n  const liveUntilMap = new Map<string, Node[]>();\n  for (let nodeOrder = 0; nodeOrder < orderedNodes.length; ++nodeOrder) {\n    const liveUntilOrder = liveUntilOrders[nodeOrder];\n    if (liveUntilOrder === INF_LIFE) {\n      continue;\n    }\n    const node = orderedNodes[nodeOrder];\n    const liveUntilNode = orderedNodes[liveUntilOrder];\n    if (!liveUntilMap.has(liveUntilNode.name)) {\n      liveUntilMap.set(liveUntilNode.name, []);\n    }\n    liveUntilMap.get(liveUntilNode.name)!.push(node);\n  }\n  return liveUntilMap;\n}\n\nconst CONTROL_FLOW_OPS = new Set([\n  'Switch', 'Merge', 'Enter', 'Exit', 'NextIteration', 'StatelessIf',\n  'StatelessWhile', 'if', 'While'\n]);\nconst DYNAMIC_SHAPE_OPS = new Set([\n  'NonMaxSuppressionV2', 'NonMaxSuppressionV3', 'NonMaxSuppressionV5', 'Where'\n]);\nconst HASH_TABLE_OPS = new Set([\n  'HashTable', 'HashTableV2', 'LookupTableImport', 'LookupTableImportV2',\n  'LookupTableFind', 'LookupTableFindV2', 'LookupTableSize', 'LookupTableSizeV2'\n]);\n\nexport function isControlFlow(node: Node) {\n  return CONTROL_FLOW_OPS.has(node.op);\n}\n\nexport function isDynamicShape(node: Node) {\n  return DYNAMIC_SHAPE_OPS.has(node.op);\n}\n\nexport function isHashTable(node: Node) {\n  return HASH_TABLE_OPS.has(node.op);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}