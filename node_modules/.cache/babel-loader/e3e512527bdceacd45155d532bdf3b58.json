{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { RaggedRange } from '../kernel_names';\nimport { convertToTensor } from '../tensor_util_env';\nimport { op } from './operation';\n/**\n * Returns a RaggedTensor result composed from rtDenseValues and rtNestedSplits,\n * such that result[i] = [starts[i], starts[i] + deltas[i], ..., limits[i]]).\n *\n * @param starts: A Tensor. Must be one of the following types:\n *     'float32', 'int32'. The starts of each range.\n * @param limits: A Tensor. Must have the same type as starts. The limits of\n *     each range.\n * @param deltas: A Tensor. Must have the same type as starts. The deltas of\n *     each range.\n * @return A map with the following properties:\n *     - rtNestedSplits: A Tensor of type 'int32'.\n *     - rtDenseValues: A Tensor. Has the same type as starts.\n */\nfunction raggedRange_(starts, limits, deltas) {\n  const $starts = convertToTensor(starts, 'starts', 'raggedRange');\n  const $limits = convertToTensor(limits, 'limits', 'raggedRange', $starts.dtype);\n  const $deltas = convertToTensor(deltas, 'deltas', 'raggedRange', $starts.dtype);\n  const inputs = {\n    starts: $starts,\n    limits: $limits,\n    deltas: $deltas\n  };\n  const result = ENGINE.runKernel(RaggedRange, inputs);\n  return {\n    rtNestedSplits: result[0],\n    rtDenseValues: result[1]\n  };\n}\nexport const raggedRange = /* @__PURE__ */op({\n  raggedRange_\n});","map":{"version":3,"sources":["../../../../../../tfjs-core/src/ops/ragged_range.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,MAAM,QAAO,WAAW;AAChC,SAAQ,WAAW,QAA0B,iBAAiB;AAG9D,SAAQ,eAAe,QAAO,oBAAoB;AAElD,SAAQ,EAAE,QAAO,aAAa;AAE9B;;;;;;;;;;;;;AAaG;AAEH,SAAS,YAAY,CACjB,MAAyB,EAAE,MAAyB,EACpD,MAAyB,EAAA;EAC3B,MAAM,OAAO,GAAG,eAAe,CAAC,MAAM,EAAE,QAAQ,EAAE,aAAa,CAAC;EAChE,MAAM,OAAO,GACT,eAAe,CAAC,MAAM,EAAE,QAAQ,EAAE,aAAa,EAAE,OAAO,CAAC,KAAK,CAAC;EACnE,MAAM,OAAO,GACT,eAAe,CAAC,MAAM,EAAE,QAAQ,EAAE,aAAa,EAAE,OAAO,CAAC,KAAK,CAAC;EAEnE,MAAM,MAAM,GAAsB;IAChC,MAAM,EAAE,OAAO;IACf,MAAM,EAAE,OAAO;IACf,MAAM,EAAE;GACT;EAED,MAAM,MAAM,GAAa,MAAM,CAAC,SAAS,CAAC,WAAW,EAAE,MAAY,CAAC;EACpE,OAAO;IACL,cAAc,EAAE,MAAM,CAAC,CAAC,CAAC;IACzB,aAAa,EAAE,MAAM,CAAC,CAAC;GACxB;AACH;AAEA,OAAO,MAAM,WAAW,GAAG,eAAgB,EAAE,CAAC;EAAC;AAAY,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {RaggedRange, RaggedRangeInputs} from '../kernel_names';\nimport {Tensor} from '../tensor';\nimport {NamedTensorMap} from '../tensor_types';\nimport {convertToTensor} from '../tensor_util_env';\nimport {TensorLike} from '../types';\nimport {op} from './operation';\n\n/**\n * Returns a RaggedTensor result composed from rtDenseValues and rtNestedSplits,\n * such that result[i] = [starts[i], starts[i] + deltas[i], ..., limits[i]]).\n *\n * @param starts: A Tensor. Must be one of the following types:\n *     'float32', 'int32'. The starts of each range.\n * @param limits: A Tensor. Must have the same type as starts. The limits of\n *     each range.\n * @param deltas: A Tensor. Must have the same type as starts. The deltas of\n *     each range.\n * @return A map with the following properties:\n *     - rtNestedSplits: A Tensor of type 'int32'.\n *     - rtDenseValues: A Tensor. Has the same type as starts.\n */\n\nfunction raggedRange_(\n    starts: Tensor|TensorLike, limits: Tensor|TensorLike,\n    deltas: Tensor|TensorLike): NamedTensorMap {\n  const $starts = convertToTensor(starts, 'starts', 'raggedRange');\n  const $limits =\n      convertToTensor(limits, 'limits', 'raggedRange', $starts.dtype);\n  const $deltas =\n      convertToTensor(deltas, 'deltas', 'raggedRange', $starts.dtype);\n\n  const inputs: RaggedRangeInputs = {\n    starts: $starts,\n    limits: $limits,\n    deltas: $deltas,\n  };\n\n  const result: Tensor[] = ENGINE.runKernel(RaggedRange, inputs as {});\n  return {\n    rtNestedSplits: result[0],\n    rtDenseValues: result[1],\n  };\n}\n\nexport const raggedRange = /* @__PURE__ */ op({raggedRange_});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}