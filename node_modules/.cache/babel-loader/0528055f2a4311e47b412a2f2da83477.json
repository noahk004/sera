{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { computeStrides, isString, rightPad, sizeFromShape } from './util';\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\nexport function tensorToString(vals, shape, dtype, verbose) {\n  const strides = computeStrides(shape);\n  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  const rank = shape.length;\n  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  const lines = ['Tensor'];\n  if (verbose) {\n    lines.push(`  dtype: ${dtype}`);\n    lines.push(`  rank: ${rank}`);\n    lines.push(`  shape: [${shape}]`);\n    lines.push(`  values:`);\n  }\n  lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n  return lines.join('\\n');\n}\nfunction computeMaxSizePerColumn(vals, shape, dtype, strides) {\n  const n = sizeFromShape(shape);\n  const numCols = strides[strides.length - 1];\n  const padPerCol = new Array(numCols).fill(0);\n  const rank = shape.length;\n  const valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;\n  if (rank > 1) {\n    for (let row = 0; row < n / numCols; row++) {\n      const offset = row * numCols;\n      for (let j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n  return padPerCol;\n}\nfunction valToString(val, pad, dtype) {\n  let valStr;\n  if (Array.isArray(val)) {\n    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` + `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n  } else if (isString(val)) {\n    valStr = `'${val}'`;\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n  return rightPad(valStr, pad);\n}\nfunction boolNumToString(v) {\n  return v === 0 ? 'false' : 'true';\n}\nfunction subTensorToString(vals, shape, dtype, strides, padPerCol, isLast = true) {\n  const storagePerElement = dtype === 'complex64' ? 2 : 1;\n  const size = shape[0];\n  const rank = shape.length;\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      const complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0])];\n    }\n    return [vals[0].toString()];\n  }\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n      let firstVals = Array.from(vals.slice(0, firstValsSize));\n      let lastVals = Array.from(vals.slice((size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement, size * storagePerElement));\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n      return ['[' + firstVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(', ') + ', ..., ' + lastVals.map((x, i) => valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype)).join(', ') + ']'];\n    }\n    const displayVals = dtype === 'complex64' ? createComplexTuples(vals) : Array.from(vals);\n    return ['[' + displayVals.map((x, i) => valToString(x, padPerCol[i], dtype)).join(', ') + ']'];\n  }\n  // The array is rank 2 or more.\n  const subshape = shape.slice(1);\n  const substrides = strides.slice(1);\n  const stride = strides[0] * storagePerElement;\n  const lines = [];\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */));\n    }\n    lines.push('...');\n    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n    }\n  } else {\n    for (let i = 0; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));\n    }\n  }\n  const sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + (size > 0 ? lines[0] + sep : '');\n  for (let i = 1; i < lines.length - 1; i++) {\n    lines[i] = ' ' + lines[i] + sep;\n  }\n  let newLineSep = ',\\n';\n  for (let i = 2; i < rank; i++) {\n    newLineSep += '\\n';\n  }\n  lines[lines.length - 1] = ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\nfunction createComplexTuples(vals) {\n  const complexTuples = [];\n  for (let i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]]);\n  }\n  return complexTuples;\n}","map":{"version":3,"sources":["../../../../../tfjs-core/src/tensor_format.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, TypedArray} from './types';\nimport {computeStrides, isString, rightPad, sizeFromShape} from './util';\n\n// Maximum number of values before we decide to show ellipsis.\nconst FORMAT_LIMIT_NUM_VALS = 20;\n// Number of first and last values to show when displaying a, b,...,y, z.\nconst FORMAT_NUM_FIRST_LAST_VALS = 3;\n// Number of significant digits to show.\nconst FORMAT_NUM_SIG_DIGITS = 7;\n\nexport function tensorToString(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    verbose: boolean) {\n  const strides = computeStrides(shape);\n  const padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);\n  const rank = shape.length;\n  const valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);\n  const lines = ['Tensor'];\n  if (verbose) {\n    lines.push(`  dtype: ${dtype}`);\n    lines.push(`  rank: ${rank}`);\n    lines.push(`  shape: [${shape}]`);\n    lines.push(`  values:`);\n  }\n  lines.push(valsLines.map(l => '    ' + l).join('\\n'));\n  return lines.join('\\n');\n}\n\nfunction computeMaxSizePerColumn(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    strides: number[]): number[] {\n  const n = sizeFromShape(shape);\n  const numCols = strides[strides.length - 1];\n  const padPerCol = new Array(numCols).fill(0);\n  const rank = shape.length;\n  const valuesOrTuples =\n      dtype === 'complex64' ? createComplexTuples(vals) : vals;\n\n  if (rank > 1) {\n    for (let row = 0; row < n / numCols; row++) {\n      const offset = row * numCols;\n      for (let j = 0; j < numCols; j++) {\n        padPerCol[j] = Math.max(\n            padPerCol[j],\n            valToString(valuesOrTuples[offset + j], 0, dtype).length);\n      }\n    }\n  }\n  return padPerCol;\n}\n\nfunction valToString(\n    val: number|string|[number, number], pad: number, dtype: DataType) {\n  let valStr: string;\n  if (Array.isArray(val)) {\n    valStr = `${parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS))} + ` +\n        `${parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS))}j`;\n  } else if (isString(val)) {\n    valStr = `'${val}'`;\n  } else if (dtype === 'bool') {\n    valStr = boolNumToString(val);\n  } else {\n    valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();\n  }\n\n  return rightPad(valStr, pad);\n}\n\nfunction boolNumToString(v: number): string {\n  return v === 0 ? 'false' : 'true';\n}\n\nfunction subTensorToString(\n    vals: TypedArray|string[], shape: number[], dtype: DataType,\n    strides: number[], padPerCol: number[], isLast = true): string[] {\n  const storagePerElement = dtype === 'complex64' ? 2 : 1;\n\n  const size = shape[0];\n  const rank = shape.length;\n  if (rank === 0) {\n    if (dtype === 'complex64') {\n      const complexTuple = createComplexTuples(vals);\n      return [valToString(complexTuple[0], 0, dtype)];\n    }\n    if (dtype === 'bool') {\n      return [boolNumToString(vals[0] as number)];\n    }\n    return [vals[0].toString()];\n  }\n\n  if (rank === 1) {\n    if (size > FORMAT_LIMIT_NUM_VALS) {\n      const firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;\n\n      let firstVals = Array.from<number|string|[number, number]>(\n          vals.slice(0, firstValsSize));\n      let lastVals = Array.from<number|string|[number, number]>(vals.slice(\n          (size - FORMAT_NUM_FIRST_LAST_VALS) * storagePerElement,\n          size * storagePerElement));\n      if (dtype === 'complex64') {\n        firstVals = createComplexTuples(firstVals);\n        lastVals = createComplexTuples(lastVals);\n      }\n      return [\n        '[' +\n        firstVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n            .join(', ') +\n        ', ..., ' +\n        lastVals\n            .map(\n                (x, i) => valToString(\n                    x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype))\n            .join(', ') +\n        ']'\n      ];\n    }\n    const displayVals: Array<number|string|[number, number]> =\n        dtype === 'complex64' ? createComplexTuples(vals) :\n                                Array.from<number|string>(vals);\n\n    return [\n      '[' +\n      displayVals.map((x, i) => valToString(x, padPerCol[i], dtype))\n          .join(', ') +\n      ']'\n    ];\n  }\n\n  // The array is rank 2 or more.\n  const subshape = shape.slice(1);\n  const substrides = strides.slice(1);\n  const stride = strides[0] * storagePerElement;\n  const lines: string[] = [];\n  if (size > FORMAT_LIMIT_NUM_VALS) {\n    for (let i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          false /* isLast */));\n    }\n    lines.push('...');\n    for (let i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          i === size - 1 /* isLast */));\n    }\n  } else {\n    for (let i = 0; i < size; i++) {\n      const start = i * stride;\n      const end = start + stride;\n      lines.push(...subTensorToString(\n          vals.slice(start, end), subshape, dtype, substrides, padPerCol,\n          i === size - 1 /* isLast */));\n    }\n  }\n  const sep = rank === 2 ? ',' : '';\n  lines[0] = '[' + (size > 0 ? lines[0] + sep : '');\n  for (let i = 1; i < lines.length - 1; i++) {\n    lines[i] = ' ' + lines[i] + sep;\n  }\n  let newLineSep = ',\\n';\n  for (let i = 2; i < rank; i++) {\n    newLineSep += '\\n';\n  }\n  lines[lines.length - 1] =\n      ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);\n  return lines;\n}\n\nfunction createComplexTuples(vals: Array<{}>|\n                             TypedArray): Array<[number, number]> {\n  const complexTuples: Array<[number, number]> = [];\n  for (let i = 0; i < vals.length; i += 2) {\n    complexTuples.push([vals[i], vals[i + 1]] as [number, number]);\n  }\n  return complexTuples;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}