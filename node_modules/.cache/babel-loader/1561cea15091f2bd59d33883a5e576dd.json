{"ast":null,"code":"import * as util from '../util';\n/**\n * Wraps a list of ArrayBuffers into a `slice()`-able object without allocating\n * a large ArrayBuffer.\n *\n * Allocating large ArrayBuffers (~2GB) can be unstable on Chrome. TFJS loads\n * its weights as a list of (usually) 4MB ArrayBuffers and then slices the\n * weight tensors out of them. For small models, it's safe to concatenate all\n * the weight buffers into a single ArrayBuffer and then slice the weight\n * tensors out of it, but for large models, a different approach is needed.\n */\nexport class CompositeArrayBuffer {\n  /**\n   * Concatenate a number of ArrayBuffers into one.\n   *\n   * @param buffers An array of ArrayBuffers to concatenate, or a single\n   *     ArrayBuffer.\n   * @returns Result of concatenating `buffers` in order.\n   */\n  static join(buffers) {\n    return new CompositeArrayBuffer(buffers).slice();\n  }\n  constructor(buffers) {\n    this.shards = [];\n    this.previousShardIndex = 0;\n    if (buffers == null) {\n      return;\n    }\n    // Normalize the `buffers` input to be `ArrayBuffer[]`.\n    if (!(buffers instanceof Array)) {\n      buffers = [buffers];\n    }\n    buffers = buffers.map(bufferOrTypedArray => {\n      if (util.isTypedArray(bufferOrTypedArray)) {\n        return bufferOrTypedArray.buffer;\n      }\n      return bufferOrTypedArray;\n    });\n    // Skip setting up shards if there are no buffers.\n    if (buffers.length === 0) {\n      return;\n    }\n    this.bufferUniformSize = buffers[0].byteLength;\n    let start = 0;\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      // Check that all buffers except the last one have the same length.\n      if (i !== buffers.length - 1 && buffer.byteLength !== this.bufferUniformSize) {\n        // Unset the buffer uniform size, since the buffer sizes are not\n        // uniform.\n        this.bufferUniformSize = undefined;\n      }\n      // Create the shards, including their start and end points.\n      const end = start + buffer.byteLength;\n      this.shards.push({\n        buffer,\n        start,\n        end\n      });\n      start = end;\n    }\n    // Set the byteLenghth\n    if (this.shards.length === 0) {\n      this.byteLength = 0;\n    }\n    this.byteLength = this.shards[this.shards.length - 1].end;\n  }\n  slice(start = 0, end = this.byteLength) {\n    // If there are no shards, then the CompositeArrayBuffer was initialized\n    // with no data.\n    if (this.shards.length === 0) {\n      return new ArrayBuffer(0);\n    }\n    // NaN is treated as zero for slicing. This matches ArrayBuffer's behavior.\n    start = isNaN(Number(start)) ? 0 : start;\n    end = isNaN(Number(end)) ? 0 : end;\n    // Fix the bounds to within the array.\n    start = Math.max(0, start);\n    end = Math.min(this.byteLength, end);\n    if (end <= start) {\n      return new ArrayBuffer(0);\n    }\n    const startShardIndex = this.findShardForByte(start);\n    if (startShardIndex === -1) {\n      // This should not happen since the start and end indices are always\n      // within 0 and the composite array's length.\n      throw new Error(`Could not find start shard for byte ${start}`);\n    }\n    const size = end - start;\n    const outputBuffer = new ArrayBuffer(size);\n    const outputArray = new Uint8Array(outputBuffer);\n    let sliced = 0;\n    for (let i = startShardIndex; i < this.shards.length; i++) {\n      const shard = this.shards[i];\n      const globalStart = start + sliced;\n      const localStart = globalStart - shard.start;\n      const outputStart = sliced;\n      const globalEnd = Math.min(end, shard.end);\n      const localEnd = globalEnd - shard.start;\n      const outputSlice = new Uint8Array(shard.buffer, localStart, localEnd - localStart);\n      outputArray.set(outputSlice, outputStart);\n      sliced += outputSlice.length;\n      if (end < shard.end) {\n        break;\n      }\n    }\n    return outputBuffer;\n  }\n  /**\n   * Get the index of the shard that contains the byte at `byteIndex`.\n   */\n  findShardForByte(byteIndex) {\n    if (this.shards.length === 0 || byteIndex < 0 || byteIndex >= this.byteLength) {\n      return -1;\n    }\n    // If the buffers have a uniform size, compute the shard directly.\n    if (this.bufferUniformSize != null) {\n      this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);\n      return this.previousShardIndex;\n    }\n    // If the buffers don't have a uniform size, we need to search for the\n    // shard. That means we need a function to check where the byteIndex lies\n    // relative to a given shard.\n    function check(shard) {\n      if (byteIndex < shard.start) {\n        return -1;\n      }\n      if (byteIndex >= shard.end) {\n        return 1;\n      }\n      return 0;\n    }\n    // For efficiency, try the previous shard first.\n    if (check(this.shards[this.previousShardIndex]) === 0) {\n      return this.previousShardIndex;\n    }\n    // Otherwise, use a generic search function.\n    // This should almost never end up being used in practice since the weight\n    // entries should always be in order.\n    const index = search(this.shards, check);\n    if (index === -1) {\n      return -1;\n    }\n    this.previousShardIndex = index;\n    return this.previousShardIndex;\n  }\n}\n/**\n * Search for an element of a sorted array.\n *\n * @param sortedArray The sorted array to search\n * @param compare A function to compare the current value against the searched\n *     value. Return 0 on a match, negative if the searched value is less than\n *     the value passed to the function, and positive if the searched value is\n *     greater than the value passed to the function.\n * @returns The index of the element, or -1 if it's not in the array.\n */\nexport function search(sortedArray, compare) {\n  // Binary search\n  let min = 0;\n  let max = sortedArray.length;\n  while (min <= max) {\n    const middle = Math.floor((max - min) / 2) + min;\n    const side = compare(sortedArray[middle]);\n    if (side === 0) {\n      return middle;\n    } else if (side < 0) {\n      max = middle;\n    } else {\n      min = middle + 1;\n    }\n  }\n  return -1;\n}","map":{"version":3,"sources":["../../../../../../tfjs-core/src/io/composite_array_buffer.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport {TypedArray} from '../types';\nimport * as util from '../util';\n\ntype BufferShard = {\n  start: number,\n  end: number,\n  buffer: ArrayBuffer,\n};\n\n/**\n * Wraps a list of ArrayBuffers into a `slice()`-able object without allocating\n * a large ArrayBuffer.\n *\n * Allocating large ArrayBuffers (~2GB) can be unstable on Chrome. TFJS loads\n * its weights as a list of (usually) 4MB ArrayBuffers and then slices the\n * weight tensors out of them. For small models, it's safe to concatenate all\n * the weight buffers into a single ArrayBuffer and then slice the weight\n * tensors out of it, but for large models, a different approach is needed.\n */\n\nexport class CompositeArrayBuffer {\n  private shards: BufferShard[] = [];\n  private previousShardIndex = 0;\n  private bufferUniformSize?: number;\n  public readonly byteLength: number;\n\n  /**\n   * Concatenate a number of ArrayBuffers into one.\n   *\n   * @param buffers An array of ArrayBuffers to concatenate, or a single\n   *     ArrayBuffer.\n   * @returns Result of concatenating `buffers` in order.\n   */\n  static join(buffers?: ArrayBuffer[] | ArrayBuffer) {\n    return new CompositeArrayBuffer(buffers).slice();\n  }\n\n  constructor(buffers?: ArrayBuffer | ArrayBuffer[] | TypedArray |\n    TypedArray[]) {\n    if (buffers == null) {\n      return;\n    }\n    // Normalize the `buffers` input to be `ArrayBuffer[]`.\n    if (!(buffers instanceof Array)) {\n      buffers = [buffers];\n    }\n    buffers = buffers.map((bufferOrTypedArray) => {\n      if (util.isTypedArray(bufferOrTypedArray)) {\n        return bufferOrTypedArray.buffer;\n      }\n      return bufferOrTypedArray;\n    });\n\n    // Skip setting up shards if there are no buffers.\n    if (buffers.length === 0) {\n      return;\n    }\n\n    this.bufferUniformSize = buffers[0].byteLength;\n    let start = 0;\n\n    for (let i = 0; i < buffers.length; i++) {\n      const buffer = buffers[i];\n      // Check that all buffers except the last one have the same length.\n      if (i !== buffers.length - 1 &&\n        buffer.byteLength !== this.bufferUniformSize) {\n        // Unset the buffer uniform size, since the buffer sizes are not\n        // uniform.\n        this.bufferUniformSize = undefined;\n      }\n\n      // Create the shards, including their start and end points.\n      const end = start + buffer.byteLength;\n      this.shards.push({ buffer, start, end });\n      start = end;\n    }\n\n    // Set the byteLenghth\n    if (this.shards.length === 0) {\n      this.byteLength = 0;\n    }\n    this.byteLength = this.shards[this.shards.length - 1].end;\n  }\n\n  slice(start = 0, end = this.byteLength): ArrayBuffer {\n    // If there are no shards, then the CompositeArrayBuffer was initialized\n    // with no data.\n    if (this.shards.length === 0) {\n      return new ArrayBuffer(0);\n    }\n\n    // NaN is treated as zero for slicing. This matches ArrayBuffer's behavior.\n    start = isNaN(Number(start)) ? 0 : start;\n    end = isNaN(Number(end)) ? 0 : end;\n\n    // Fix the bounds to within the array.\n    start = Math.max(0, start);\n    end = Math.min(this.byteLength, end);\n    if (end <= start) {\n      return new ArrayBuffer(0);\n    }\n\n    const startShardIndex = this.findShardForByte(start);\n    if (startShardIndex === -1) {\n      // This should not happen since the start and end indices are always\n      // within 0 and the composite array's length.\n      throw new Error(`Could not find start shard for byte ${start}`);\n    }\n\n    const size = end - start;\n    const outputBuffer = new ArrayBuffer(size);\n    const outputArray = new Uint8Array(outputBuffer);\n    let sliced = 0;\n    for (let i = startShardIndex; i < this.shards.length; i++) {\n      const shard = this.shards[i];\n\n      const globalStart = start + sliced;\n      const localStart = globalStart - shard.start;\n      const outputStart = sliced;\n\n      const globalEnd = Math.min(end, shard.end);\n      const localEnd = globalEnd - shard.start;\n\n      const outputSlice = new Uint8Array(shard.buffer, localStart,\n                                         localEnd - localStart);\n      outputArray.set(outputSlice, outputStart);\n      sliced += outputSlice.length;\n\n      if (end < shard.end) {\n        break;\n      }\n    }\n    return outputBuffer;\n  }\n\n  /**\n   * Get the index of the shard that contains the byte at `byteIndex`.\n   */\n  private findShardForByte(byteIndex: number): number {\n    if (this.shards.length === 0 || byteIndex < 0 ||\n      byteIndex >= this.byteLength) {\n      return -1;\n    }\n\n    // If the buffers have a uniform size, compute the shard directly.\n    if (this.bufferUniformSize != null) {\n      this.previousShardIndex = Math.floor(byteIndex / this.bufferUniformSize);\n      return this.previousShardIndex;\n    }\n\n    // If the buffers don't have a uniform size, we need to search for the\n    // shard. That means we need a function to check where the byteIndex lies\n    // relative to a given shard.\n    function check(shard: BufferShard) {\n      if (byteIndex < shard.start) {\n        return -1;\n      }\n      if (byteIndex >= shard.end) {\n        return 1;\n      }\n      return 0;\n    }\n\n    // For efficiency, try the previous shard first.\n    if (check(this.shards[this.previousShardIndex]) === 0) {\n      return this.previousShardIndex;\n    }\n\n    // Otherwise, use a generic search function.\n    // This should almost never end up being used in practice since the weight\n    // entries should always be in order.\n    const index = search(this.shards, check);\n    if (index === -1) {\n      return -1;\n    }\n\n    this.previousShardIndex = index;\n    return this.previousShardIndex;\n  }\n}\n\n/**\n * Search for an element of a sorted array.\n *\n * @param sortedArray The sorted array to search\n * @param compare A function to compare the current value against the searched\n *     value. Return 0 on a match, negative if the searched value is less than\n *     the value passed to the function, and positive if the searched value is\n *     greater than the value passed to the function.\n * @returns The index of the element, or -1 if it's not in the array.\n */\nexport function search<T>(sortedArray: T[], compare: (t: T) => number): number {\n  // Binary search\n  let min = 0;\n  let max = sortedArray.length;\n\n  while (min <= max) {\n    const middle = Math.floor((max - min) / 2) + min;\n    const side = compare(sortedArray[middle]);\n\n    if (side === 0) {\n      return middle;\n    } else if (side < 0) {\n      max = middle;\n    } else {\n      min = middle + 1;\n    }\n  }\n  return -1;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}