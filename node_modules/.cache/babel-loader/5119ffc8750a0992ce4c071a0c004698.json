{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n/**\n * Gets the new shape of the input Tensor after it's been reshaped\n * to:\n * [blockShape[0], ..., blockShape[M-1], batch / prod(blockShape),\n * inputShape[1], ..., inputShape[N-1]]\n *\n * See step 1: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshaped(inputShape, blockShape, prod, batchToSpace = true) {\n  let reshaped = [];\n  if (batchToSpace) {\n    reshaped = reshaped.concat(blockShape.slice(0));\n    reshaped.push(inputShape[0] / prod);\n    reshaped = reshaped.concat(inputShape.slice(1));\n  } else {\n    reshaped = reshaped.concat(inputShape[0]);\n    const spatialLength = blockShape.length;\n    for (let i = 0; i < spatialLength; ++i) {\n      reshaped = reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);\n    }\n    reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));\n  }\n  return reshaped;\n}\n/**\n * Gets the permutation that will transpose the dimensions of the\n * reshaped tensor to shape:\n *\n * [batch / prod(block_shape),inputShape[1], blockShape[0], ...,\n * inputShape[M], blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * see step 2: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getPermuted(reshapedRank, blockShapeRank, batchToSpace = true) {\n  const permuted = [];\n  if (batchToSpace) {\n    permuted.push(blockShapeRank);\n    for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {\n      if (i <= 2 * blockShapeRank) {\n        permuted.push(i);\n        permuted.push(i - (blockShapeRank + 1));\n      } else {\n        permuted.push(i);\n      }\n    }\n  } else {\n    const permutedBeforeBatch = [];\n    const permutedAfterBatch = [];\n    for (let i = 1; i < reshapedRank; ++i) {\n      if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {\n        permutedAfterBatch.push(i);\n      } else {\n        permutedBeforeBatch.push(i);\n      }\n    }\n    permuted.push(...permutedBeforeBatch);\n    permuted.push(0);\n    permuted.push(...permutedAfterBatch);\n  }\n  return permuted;\n}\n/**\n * Gets the shape of the reshaped and permuted input Tensor before any cropping\n * is applied.  The new shape will be:\n *\n * [batch / prod(blockShape),inputShape[1] * blockShape[0], ...,\n * inputShape[M] * blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 3: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshapedPermuted(inputShape, blockShape, prod, batchToSpace = true) {\n  const reshapedPermuted = [];\n  if (batchToSpace) {\n    reshapedPermuted.push(inputShape[0] / prod);\n  } else {\n    reshapedPermuted.push(inputShape[0] * prod);\n  }\n  for (let i = 1; i < inputShape.length; ++i) {\n    if (i <= blockShape.length) {\n      if (batchToSpace) {\n        reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);\n      } else {\n        reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);\n      }\n    } else {\n      reshapedPermuted.push(inputShape[i]);\n    }\n  }\n  return reshapedPermuted;\n}\n/**\n * Converts the crops argument into the beginning coordinates of a slice\n * operation.\n */\nexport function getSliceBeginCoords(crops, blockShape) {\n  const sliceBeginCoords = [0];\n  for (let i = 0; i < blockShape; ++i) {\n    sliceBeginCoords.push(crops[i][0]);\n  }\n  return sliceBeginCoords;\n}\n/**\n * Converts the crops argument into the size of a slice operation.  When\n * combined with getSliceBeginCoords this function allows the reshaped and\n * permuted Tensor to be cropped to its final output shape of:\n *\n * inputShape[1] * blockShape[0] - crops[0,0] - crops[0,1], ...,\n * inputShape[M] * blockShape[M-1] -crops[M-1,0] -\n * crops[M-1,1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 4: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getSliceSize(uncroppedShape, crops, blockShape) {\n  const sliceSize = uncroppedShape.slice(0, 1);\n  for (let i = 0; i < blockShape; ++i) {\n    sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);\n  }\n  return sliceSize;\n}","map":{"version":3,"sources":["../../../../../../tfjs-core/src/ops/array_ops_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\n/**\n * Gets the new shape of the input Tensor after it's been reshaped\n * to:\n * [blockShape[0], ..., blockShape[M-1], batch / prod(blockShape),\n * inputShape[1], ..., inputShape[N-1]]\n *\n * See step 1: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshaped(\n    inputShape: number[], blockShape: number[], prod: number,\n    batchToSpace = true): number[] {\n  let reshaped: number[] = [];\n  if (batchToSpace) {\n    reshaped = reshaped.concat(blockShape.slice(0));\n    reshaped.push(inputShape[0] / prod);\n    reshaped = reshaped.concat(inputShape.slice(1));\n  } else {\n    reshaped = reshaped.concat(inputShape[0]);\n    const spatialLength = blockShape.length;\n    for (let i = 0; i < spatialLength; ++i) {\n      reshaped =\n          reshaped.concat([inputShape[i + 1] / blockShape[i], blockShape[i]]);\n    }\n    reshaped = reshaped.concat(inputShape.slice(spatialLength + 1));\n  }\n  return reshaped;\n}\n\n/**\n * Gets the permutation that will transpose the dimensions of the\n * reshaped tensor to shape:\n *\n * [batch / prod(block_shape),inputShape[1], blockShape[0], ...,\n * inputShape[M], blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * see step 2: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getPermuted(\n    reshapedRank: number, blockShapeRank: number,\n    batchToSpace = true): number[] {\n  const permuted = [];\n  if (batchToSpace) {\n    permuted.push(blockShapeRank);\n    for (let i = blockShapeRank + 1; i < reshapedRank; ++i) {\n      if (i <= 2 * blockShapeRank) {\n        permuted.push(i);\n        permuted.push(i - (blockShapeRank + 1));\n      } else {\n        permuted.push(i);\n      }\n    }\n  } else {\n    const permutedBeforeBatch = [];\n    const permutedAfterBatch = [];\n    for (let i = 1; i < reshapedRank; ++i) {\n      if (i >= blockShapeRank * 2 + 1 || i % 2 === 1) {\n        permutedAfterBatch.push(i);\n      } else {\n        permutedBeforeBatch.push(i);\n      }\n    }\n    permuted.push(...permutedBeforeBatch);\n    permuted.push(0);\n    permuted.push(...permutedAfterBatch);\n  }\n  return permuted;\n}\n\n/**\n * Gets the shape of the reshaped and permuted input Tensor before any cropping\n * is applied.  The new shape will be:\n *\n * [batch / prod(blockShape),inputShape[1] * blockShape[0], ...,\n * inputShape[M] * blockShape[M-1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 3: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getReshapedPermuted(\n    inputShape: number[], blockShape: number[], prod: number,\n    batchToSpace = true): number[] {\n  const reshapedPermuted = [];\n\n  if (batchToSpace) {\n    reshapedPermuted.push(inputShape[0] / prod);\n  } else {\n    reshapedPermuted.push(inputShape[0] * prod);\n  }\n\n  for (let i = 1; i < inputShape.length; ++i) {\n    if (i <= blockShape.length) {\n      if (batchToSpace) {\n        reshapedPermuted.push(blockShape[i - 1] * inputShape[i]);\n      } else {\n        reshapedPermuted.push(inputShape[i] / blockShape[i - 1]);\n      }\n    } else {\n      reshapedPermuted.push(inputShape[i]);\n    }\n  }\n\n  return reshapedPermuted;\n}\n\n/**\n * Converts the crops argument into the beginning coordinates of a slice\n * operation.\n */\nexport function getSliceBeginCoords(\n    crops: number[][], blockShape: number): number[] {\n  const sliceBeginCoords = [0];\n  for (let i = 0; i < blockShape; ++i) {\n    sliceBeginCoords.push(crops[i][0]);\n  }\n  return sliceBeginCoords;\n}\n\n/**\n * Converts the crops argument into the size of a slice operation.  When\n * combined with getSliceBeginCoords this function allows the reshaped and\n * permuted Tensor to be cropped to its final output shape of:\n *\n * inputShape[1] * blockShape[0] - crops[0,0] - crops[0,1], ...,\n * inputShape[M] * blockShape[M-1] -crops[M-1,0] -\n * crops[M-1,1],inputShape[M+1], ..., inputShape[N-1]]\n *\n * See step 4: https://www.tensorflow.org/api_docs/python/tf/batch_to_space_nd\n */\nexport function getSliceSize(\n    uncroppedShape: number[], crops: number[][], blockShape: number): number[] {\n  const sliceSize = uncroppedShape.slice(0, 1);\n  for (let i = 0; i < blockShape; ++i) {\n    sliceSize.push(uncroppedShape[i + 1] - crops[i][0] - crops[i][1]);\n  }\n\n  return sliceSize;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}