{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nexport var RowPartitionType;\n(function (RowPartitionType) {\n  RowPartitionType[RowPartitionType[\"FIRST_DIM_SIZE\"] = 0] = \"FIRST_DIM_SIZE\";\n  RowPartitionType[RowPartitionType[\"VALUE_ROWIDS\"] = 1] = \"VALUE_ROWIDS\";\n  RowPartitionType[RowPartitionType[\"ROW_LENGTHS\"] = 2] = \"ROW_LENGTHS\";\n  RowPartitionType[RowPartitionType[\"ROW_SPLITS\"] = 3] = \"ROW_SPLITS\";\n  RowPartitionType[RowPartitionType[\"ROW_LIMITS\"] = 4] = \"ROW_LIMITS\";\n  RowPartitionType[RowPartitionType[\"ROW_STARTS\"] = 5] = \"ROW_STARTS\";\n})(RowPartitionType || (RowPartitionType = {}));\nexport function combineRaggedTensorToTensorShapes(raggedRank, shape, valueShape) {\n  // Test for consistency of valueShape and shape specified.\n  // If shape is unspecified and valueShape is specified, then copy\n  // over the size from the valueShape dimension.\n  let outputShape = new Array();\n  if (valueShape == null && shape == null) {\n    return outputShape;\n  }\n  if (shape == null) {\n    // Here, value_shape must be of known size.\n    while (outputShape.length < raggedRank + valueShape.length) {\n      outputShape.push(-1);\n    }\n  } else {\n    outputShape = shape.slice();\n  }\n  if (valueShape == null) {\n    return outputShape;\n  }\n  // At this point, valueShape and output_shape have known ranks.\n  if (raggedRank + valueShape.length !== outputShape.length) {\n    throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.rank = ${raggedRank + valueShape.length}, but shape.rank = ${outputShape.length}`);\n  }\n  for (let i = 1; i < valueShape.length; ++i) {\n    const valueDim = valueShape[i];\n    const outputShapeDimIndex = outputShape[outputShape.length - valueShape.length + i];\n    const outputShapeDim = outputShape[outputShapeDimIndex];\n    if (valueDim >= 0) {\n      if (outputShapeDim >= 0) {\n        if (outputShapeDim !== valueDim) {\n          throw new Error(`rt input.shape and shape=${shape} are incompatible: rt input.shape[${i + raggedRank}] = ${valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);\n        }\n      } else {\n        outputShape[outputShapeDimIndex] = valueDim;\n      }\n    }\n  }\n  return outputShape;\n}\nexport function getRowPartitionTypesHelper(rowPartitionTypeStrings) {\n  const stringToType = {\n    'FIRST_DIM_SIZE': RowPartitionType.FIRST_DIM_SIZE,\n    'VALUE_ROWIDS': RowPartitionType.VALUE_ROWIDS,\n    'ROW_LENGTHS': RowPartitionType.ROW_LENGTHS,\n    'ROW_SPLITS': RowPartitionType.ROW_SPLITS,\n    'ROW_LIMITS': RowPartitionType.ROW_LIMITS,\n    'ROW_STARTS': RowPartitionType.ROW_STARTS\n  };\n  const result = [];\n  for (const typeStr of rowPartitionTypeStrings) {\n    if (typeStr in stringToType) {\n      result.push(stringToType[typeStr]);\n    } else {\n      break;\n    }\n  }\n  return result;\n}\nexport function getRaggedRank(rowPartitionTypes) {\n  if (rowPartitionTypes.length === 0) {\n    return 0;\n  }\n  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n    return rowPartitionTypes.length - 1;\n  }\n  return rowPartitionTypes.length;\n}\nexport function validateDefaultValueShape(defaultValueShape, valueShape) {\n  if (defaultValueShape == null || valueShape == null) {\n    return;\n  }\n  const defaultNDims = defaultValueShape.length;\n  const valuesNDims = valueShape.length;\n  if (defaultNDims >= valuesNDims) {\n    throw new Error(`defaultValue.shape=${defaultValueShape} and ragged tensor flatValues.shape=${valueShape}, are incompatible: defaultValue.rank = ${defaultNDims} must be less than ragged tensor input flatValues.rank = ${valuesNDims})`);\n  }\n  for (let i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {\n    const defaultDim = defaultValueShape[i];\n    const valueDim = valueShape[i + 1];\n    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 && defaultDim !== valueDim) {\n      throw new Error(`defaultValue.shape=${defaultValueShape}, and ragged tensor input flatValues.shape=${valueShape} are incompatible: defaultValue.shape[${i - defaultValueShape.length}] = ${defaultDim} but ragged tensor input.flatValues.shape[${i - defaultValueShape.length}] = ${valueDim}`);\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../../tfjs-core/src/ops/ragged_to_dense_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nexport enum RowPartitionType {\n  FIRST_DIM_SIZE,\n  VALUE_ROWIDS,\n  ROW_LENGTHS,\n  ROW_SPLITS,\n  ROW_LIMITS,\n  ROW_STARTS\n}\n\nexport function combineRaggedTensorToTensorShapes(\n    raggedRank: number, shape: number[], valueShape: number[]) {\n  // Test for consistency of valueShape and shape specified.\n  // If shape is unspecified and valueShape is specified, then copy\n  // over the size from the valueShape dimension.\n\n  let outputShape: number[] = new Array();\n  if (valueShape == null && shape == null) {\n    return outputShape;\n  }\n\n  if (shape == null) {\n    // Here, value_shape must be of known size.\n    while (outputShape.length < raggedRank + valueShape.length) {\n      outputShape.push(-1);\n    }\n  } else {\n    outputShape = shape.slice();\n  }\n  if (valueShape == null) {\n    return outputShape;\n  }\n  // At this point, valueShape and output_shape have known ranks.\n  if (raggedRank + valueShape.length !== outputShape.length) {\n    throw new Error(\n        `rt input.shape and shape=${shape} are incompatible: rt input.rank = ${\n            raggedRank +\n            valueShape.length}, but shape.rank = ${outputShape.length}`);\n  }\n\n  for (let i = 1; i < valueShape.length; ++i) {\n    const valueDim = valueShape[i];\n    const outputShapeDimIndex =\n        outputShape[outputShape.length - valueShape.length + i];\n    const outputShapeDim = outputShape[outputShapeDimIndex];\n\n    if (valueDim >= 0) {\n      if (outputShapeDim >= 0) {\n        if (outputShapeDim !== valueDim) {\n          throw new Error(`rt input.shape and shape=${\n              shape} are incompatible: rt input.shape[${i + raggedRank}] = ${\n              valueDim} but shape[${i + raggedRank}] = ${outputShapeDim}`);\n        }\n      } else {\n        outputShape[outputShapeDimIndex] = valueDim;\n      }\n    }\n  }\n  return outputShape;\n}\n\nexport function getRowPartitionTypesHelper(rowPartitionTypeStrings: string[]) {\n  const stringToType = {\n    'FIRST_DIM_SIZE': RowPartitionType.FIRST_DIM_SIZE,\n    'VALUE_ROWIDS': RowPartitionType.VALUE_ROWIDS,\n    'ROW_LENGTHS': RowPartitionType.ROW_LENGTHS,\n    'ROW_SPLITS': RowPartitionType.ROW_SPLITS,\n    'ROW_LIMITS': RowPartitionType.ROW_LIMITS,\n    'ROW_STARTS': RowPartitionType.ROW_STARTS\n  };\n\n  const result: RowPartitionType[] = [];\n  for (const typeStr of rowPartitionTypeStrings) {\n    if (typeStr in stringToType) {\n      result.push(stringToType[typeStr as keyof typeof stringToType]);\n    } else {\n      break;\n    }\n  }\n\n  return result;\n}\n\nexport function getRaggedRank(rowPartitionTypes: RowPartitionType[]) {\n  if (rowPartitionTypes.length === 0) {\n    return 0;\n  }\n  if (rowPartitionTypes[0] === RowPartitionType.FIRST_DIM_SIZE) {\n    return rowPartitionTypes.length - 1;\n  }\n  return rowPartitionTypes.length;\n}\n\nexport function validateDefaultValueShape(\n    defaultValueShape: number[], valueShape: number[]) {\n  if (defaultValueShape == null || valueShape == null) {\n    return;\n  }\n\n  const defaultNDims = defaultValueShape.length;\n  const valuesNDims = valueShape.length;\n  if (defaultNDims >= valuesNDims) {\n    throw new Error(`defaultValue.shape=${\n        defaultValueShape} and ragged tensor flatValues.shape=${\n        valueShape}, are incompatible: defaultValue.rank = ${\n        defaultNDims} must be less than ragged tensor input flatValues.rank = ${\n        valuesNDims})`);\n  }\n  for (let i = 0; i < Math.min(defaultNDims, valuesNDims - 1); ++i) {\n    const defaultDim = defaultValueShape[i];\n    const valueDim = valueShape[i + 1];\n    if (defaultDim >= 0 && valueDim >= 0 && defaultDim !== 1 &&\n        defaultDim !== valueDim) {\n      throw new Error(`defaultValue.shape=${\n          defaultValueShape}, and ragged tensor input flatValues.shape=${\n          valueShape} are incompatible: defaultValue.shape[${\n          i - defaultValueShape.length}] = ${\n          defaultDim} but ragged tensor input.flatValues.shape[${\n          i - defaultValueShape.length}] = ${valueDim}`);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}