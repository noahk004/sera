{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport * as tensorflow from '../data/compiled_api';\nimport { getRegisteredOp } from './custom_op/register';\nimport { getNodeNameAndIndex } from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as sparse from './op_list/sparse';\nimport * as spectral from './op_list/spectral';\nimport * as string from './op_list/string';\nimport * as transformation from './op_list/transformation';\nexport class OperationMapper {\n  // Singleton instance for the mapper\n  static get Instance() {\n    return this._instance || (this._instance = new this());\n  }\n  // Loads the op mapping from the JSON file.\n  constructor() {\n    const ops = [arithmetic, basicMath, control, convolution, creation, dynamic, evaluation, graph, hashTable, image, logical, matrices, normalization, reduction, sliceJoin, sparse, spectral, string, transformation];\n    const mappersJson = [].concat(...ops.map(op => op.json));\n    this.opMappers = mappersJson.reduce((map, mapper) => {\n      map[mapper.tfOpName] = mapper;\n      return map;\n    }, {});\n  }\n  // Converts the model inference graph from Tensorflow GraphDef to local\n  // representation for TensorFlow.js API\n  transformGraph(graph, signature = {}) {\n    const tfNodes = graph.node;\n    const placeholders = [];\n    const weights = [];\n    const initNodes = [];\n    const nodes = tfNodes.reduce((map, node) => {\n      map[node.name] = this.mapNode(node);\n      if (node.op.startsWith('Placeholder')) {\n        placeholders.push(map[node.name]);\n      } else if (node.op === 'Const') {\n        weights.push(map[node.name]);\n      } else if (node.input == null || node.input.length === 0) {\n        initNodes.push(map[node.name]);\n      }\n      return map;\n    }, {});\n    let inputs = [];\n    const outputs = [];\n    let inputNodeNameToKey = {};\n    let outputNodeNameToKey = {};\n    if (signature != null) {\n      inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n      outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n    }\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName,, outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`;\n            // update the input name to use the mapped output index directly.\n            node.inputNames[index] = inputName;\n          }\n        }\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    });\n    // if signature has not outputs set, add any node that does not have\n    // outputs.\n    if (Object.keys(outputNodeNameToKey).length === 0) {\n      allNodes.forEach(key => {\n        const node = nodes[key];\n        if (node.children.length === 0) {\n          outputs.push(node);\n        }\n      });\n    } else {\n      Object.keys(outputNodeNameToKey).forEach(name => {\n        const [nodeName] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n        if (node != null) {\n          node.signatureKey = outputNodeNameToKey[name];\n          outputs.push(node);\n        }\n      });\n    }\n    if (Object.keys(inputNodeNameToKey).length > 0) {\n      Object.keys(inputNodeNameToKey).forEach(name => {\n        const [nodeName] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n        if (node) {\n          node.signatureKey = inputNodeNameToKey[name];\n          inputs.push(node);\n        }\n      });\n    } else {\n      inputs = placeholders;\n    }\n    let functions = {};\n    if (graph.library != null && graph.library.function != null) {\n      functions = graph.library.function.reduce((functions, func) => {\n        functions[func.signature.name] = this.mapFunction(func);\n        return functions;\n      }, {});\n    }\n    const result = {\n      nodes,\n      inputs,\n      outputs,\n      weights,\n      placeholders,\n      signature,\n      functions\n    };\n    if (initNodes.length > 0) {\n      result.initNodes = initNodes;\n    }\n    return result;\n  }\n  mapSignatureEntries(entries) {\n    return Object.keys(entries || {}).reduce((prev, curr) => {\n      prev[entries[curr].name] = curr;\n      return prev;\n    }, {});\n  }\n  mapNode(node) {\n    // Unsupported ops will cause an error at run-time (not parse time), since\n    // they may not be used by the actual execution subgraph.\n    const mapper = getRegisteredOp(node.op) || this.opMappers[node.op] || {};\n    if (node.attr == null) {\n      node.attr = {};\n    }\n    const newNode = {\n      name: node.name,\n      op: node.op,\n      category: mapper.category,\n      inputNames: (node.input || []).map(input => input.startsWith('^') ? input.slice(1) : input),\n      inputs: [],\n      children: [],\n      inputParams: {},\n      attrParams: {},\n      rawAttrs: node.attr,\n      outputs: mapper.outputs\n    };\n    if (mapper.inputs != null) {\n      newNode.inputParams = mapper.inputs.reduce((map, param) => {\n        map[param.name] = {\n          type: param.type,\n          inputIndexStart: param.start,\n          inputIndexEnd: param.end\n        };\n        return map;\n      }, {});\n    }\n    if (mapper.attrs != null) {\n      newNode.attrParams = mapper.attrs.reduce((map, param) => {\n        const type = param.type;\n        let value = undefined;\n        switch (param.type) {\n          case 'string':\n            value = getStringParam(node.attr, param.tfName, param.defaultValue);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getStringParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'string[]':\n            value = getStringArrayParam(node.attr, param.tfName, param.defaultValue);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getStringArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'number':\n            value = getNumberParam(node.attr, param.tfName, param.defaultValue || 0);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getNumberParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'number[]':\n            value = getNumericArrayParam(node.attr, param.tfName, param.defaultValue);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getNumericArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'bool':\n            value = getBoolParam(node.attr, param.tfName, param.defaultValue);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getBoolParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'bool[]':\n            value = getBoolArrayParam(node.attr, param.tfName, param.defaultValue);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getBoolArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'shape':\n            value = getTensorShapeParam(node.attr, param.tfName, param.defaultValue);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getTensorShapeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'shape[]':\n            value = getTensorShapeArrayParam(node.attr, param.tfName, param.defaultValue);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getTensorShapeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'dtype':\n            value = getDtypeParam(node.attr, param.tfName, param.defaultValue);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getDtypeParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'dtype[]':\n            value = getDtypeArrayParam(node.attr, param.tfName, param.defaultValue);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getDtypeArrayParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'func':\n            value = getFuncParam(node.attr, param.tfName, param.defaultValue);\n            if (value === undefined && !!param.tfDeprecatedName) {\n              value = getFuncParam(node.attr, param.tfDeprecatedName, param.defaultValue);\n            }\n            break;\n          case 'tensor':\n          case 'tensors':\n            break;\n          default:\n            throw new Error(`Unsupported param type: ${param.type} for op: ${node.op}`);\n        }\n        map[param.name] = {\n          value,\n          type\n        };\n        return map;\n      }, {});\n    }\n    return newNode;\n  }\n  // map the TFunctionDef to TFJS graph object\n  mapFunction(functionDef) {\n    const tfNodes = functionDef.nodeDef;\n    const placeholders = [];\n    const weights = [];\n    let nodes = {};\n    if (tfNodes != null) {\n      nodes = tfNodes.reduce((map, node) => {\n        map[node.name] = this.mapNode(node);\n        if (node.op === 'Const') {\n          weights.push(map[node.name]);\n        }\n        return map;\n      }, {});\n    }\n    const inputs = [];\n    const outputs = [];\n    functionDef.signature.inputArg.forEach(arg => {\n      const [nodeName] = getNodeNameAndIndex(arg.name);\n      const node = {\n        name: nodeName,\n        op: 'Placeholder',\n        inputs: [],\n        inputNames: [],\n        category: 'graph',\n        inputParams: {},\n        attrParams: {\n          dtype: {\n            value: parseDtypeParam(arg.type),\n            type: 'dtype'\n          }\n        },\n        children: []\n      };\n      node.signatureKey = arg.name;\n      inputs.push(node);\n      nodes[nodeName] = node;\n    });\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName,, outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`;\n            // update the input name to use the mapped output index directly.\n            node.inputNames[index] = inputName;\n          }\n        }\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    });\n    const returnNodeMap = functionDef.ret;\n    functionDef.signature.outputArg.forEach(output => {\n      const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);\n      const node = nodes[nodeName];\n      if (node != null) {\n        node.defaultOutput = index;\n        outputs.push(node);\n      }\n    });\n    const signature = this.mapArgsToSignature(functionDef);\n    return {\n      nodes,\n      inputs,\n      outputs,\n      weights,\n      placeholders,\n      signature\n    };\n  }\n  mapArgsToSignature(functionDef) {\n    return {\n      methodName: functionDef.signature.name,\n      inputs: functionDef.signature.inputArg.reduce((map, arg) => {\n        map[arg.name] = this.mapArgToTensorInfo(arg);\n        return map;\n      }, {}),\n      outputs: functionDef.signature.outputArg.reduce((map, arg) => {\n        map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);\n        return map;\n      }, {})\n    };\n  }\n  mapArgToTensorInfo(arg, nameMap) {\n    let name = arg.name;\n    if (nameMap != null) {\n      name = nameMap[name];\n    }\n    return {\n      name,\n      dtype: arg.type\n    };\n  }\n}\nexport function decodeBase64(text) {\n  const global = env().global;\n  if (typeof global.atob !== 'undefined') {\n    return global.atob(text);\n  } else if (typeof Buffer !== 'undefined') {\n    return new Buffer(text, 'base64').toString();\n  } else {\n    throw new Error('Unable to decode base64 in this environment. ' + 'Missing built-in atob() or Buffer()');\n  }\n}\nexport function parseStringParam(s, keepCase) {\n  const value = Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n  return keepCase ? value : value.toLowerCase();\n}\nexport function getStringParam(attrs, name, def, keepCase = false) {\n  const param = attrs[name];\n  if (param != null) {\n    return parseStringParam(param.s, keepCase);\n  }\n  return def;\n}\nexport function getBoolParam(attrs, name, def) {\n  const param = attrs[name];\n  return param ? param.b : def;\n}\nexport function getNumberParam(attrs, name, def) {\n  const param = attrs[name] || {};\n  const value = param['i'] != null ? param['i'] : param['f'] != null ? param['f'] : def;\n  return typeof value === 'number' ? value : parseInt(value, 10);\n}\nexport function parseDtypeParam(value) {\n  if (typeof value === 'string') {\n    // tslint:disable-next-line:no-any\n    value = tensorflow.DataType[value];\n  }\n  switch (value) {\n    case tensorflow.DataType.DT_FLOAT:\n    case tensorflow.DataType.DT_HALF:\n      return 'float32';\n    case tensorflow.DataType.DT_INT32:\n    case tensorflow.DataType.DT_INT64:\n    case tensorflow.DataType.DT_INT8:\n    case tensorflow.DataType.DT_UINT8:\n      return 'int32';\n    case tensorflow.DataType.DT_BOOL:\n      return 'bool';\n    case tensorflow.DataType.DT_DOUBLE:\n      return 'float32';\n    case tensorflow.DataType.DT_STRING:\n      return 'string';\n    case tensorflow.DataType.DT_COMPLEX64:\n    case tensorflow.DataType.DT_COMPLEX128:\n      return 'complex64';\n    default:\n      // Unknown dtype error will happen at runtime (instead of parse time),\n      // since these nodes might not be used by the actual subgraph execution.\n      return null;\n  }\n}\nexport function getFuncParam(attrs, name, def) {\n  const param = attrs[name];\n  if (param && param.func) {\n    return param.func.name;\n  }\n  return def;\n}\nexport function getDtypeParam(attrs, name, def) {\n  const param = attrs[name];\n  if (param && param.type) {\n    return parseDtypeParam(param.type);\n  }\n  return def;\n}\nexport function getDtypeArrayParam(attrs, name, def) {\n  const param = attrs[name];\n  if (param && param.list && param.list.type) {\n    return param.list.type.map(v => parseDtypeParam(v));\n  }\n  return def;\n}\nexport function parseTensorShapeParam(shape) {\n  if (shape.unknownRank) {\n    return undefined;\n  }\n  if (shape.dim != null) {\n    return shape.dim.map(dim => typeof dim.size === 'number' ? dim.size : parseInt(dim.size, 10));\n  }\n  return [];\n}\nexport function getTensorShapeParam(attrs, name, def) {\n  const param = attrs[name];\n  if (param && param.shape) {\n    return parseTensorShapeParam(param.shape);\n  }\n  return def;\n}\nexport function getNumericArrayParam(attrs, name, def) {\n  const param = attrs[name];\n  if (param) {\n    return ((param.list.f && param.list.f.length ? param.list.f : param.list.i) || []).map(v => typeof v === 'number' ? v : parseInt(v, 10));\n  }\n  return def;\n}\nexport function getStringArrayParam(attrs, name, def, keepCase = false) {\n  const param = attrs[name];\n  if (param && param.list && param.list.s) {\n    return param.list.s.map(v => {\n      return parseStringParam(v, keepCase);\n    });\n  }\n  return def;\n}\nexport function getTensorShapeArrayParam(attrs, name, def) {\n  const param = attrs[name];\n  if (param && param.list && param.list.shape) {\n    return param.list.shape.map(v => {\n      return parseTensorShapeParam(v);\n    });\n  }\n  return def;\n}\nexport function getBoolArrayParam(attrs, name, def) {\n  const param = attrs[name];\n  if (param && param.list && param.list.b) {\n    return param.list.b;\n  }\n  return def;\n}","map":{"version":3,"sources":["../../../../../../tfjs-converter/src/operations/operation_mapper.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {DataType, env} from '@tensorflow/tfjs-core';\n\nimport * as tensorflow from '../data/compiled_api';\n\nimport {getRegisteredOp} from './custom_op/register';\nimport {getNodeNameAndIndex} from './executors/utils';\nimport * as arithmetic from './op_list/arithmetic';\nimport * as basicMath from './op_list/basic_math';\nimport * as control from './op_list/control';\nimport * as convolution from './op_list/convolution';\nimport * as creation from './op_list/creation';\nimport * as dynamic from './op_list/dynamic';\nimport * as evaluation from './op_list/evaluation';\nimport * as graph from './op_list/graph';\nimport * as hashTable from './op_list/hash_table';\nimport * as image from './op_list/image';\nimport * as logical from './op_list/logical';\nimport * as matrices from './op_list/matrices';\nimport * as normalization from './op_list/normalization';\nimport * as reduction from './op_list/reduction';\nimport * as sliceJoin from './op_list/slice_join';\nimport * as sparse from './op_list/sparse';\nimport * as spectral from './op_list/spectral';\nimport * as string from './op_list/string';\nimport * as transformation from './op_list/transformation';\nimport {Graph, InputParamValue, Node, OpMapper, ParamValue} from './types';\n\nexport class OperationMapper {\n  private static _instance: OperationMapper;\n\n  private opMappers: {[key: string]: OpMapper};\n\n  // Singleton instance for the mapper\n  public static get Instance() {\n    return this._instance || (this._instance = new this());\n  }\n\n  // Loads the op mapping from the JSON file.\n  private constructor() {\n    const ops = [\n      arithmetic, basicMath, control, convolution, creation, dynamic,\n      evaluation, graph, hashTable, image, logical, matrices, normalization,\n      reduction, sliceJoin, sparse, spectral, string, transformation\n    ];\n    const mappersJson: OpMapper[] = [].concat(...ops.map(op => op.json));\n\n    this.opMappers = mappersJson.reduce<{[key: string]: OpMapper}>(\n        (map, mapper: OpMapper) => {\n          map[mapper.tfOpName] = mapper;\n          return map;\n        },\n        {});\n  }\n\n  // Converts the model inference graph from Tensorflow GraphDef to local\n  // representation for TensorFlow.js API\n  transformGraph(\n      graph: tensorflow.IGraphDef,\n      signature: tensorflow.ISignatureDef = {}): Graph {\n    const tfNodes = graph.node;\n    const placeholders: Node[] = [];\n    const weights: Node[] = [];\n    const initNodes: Node[] = [];\n    const nodes = tfNodes.reduce<{[key: string]: Node}>((map, node) => {\n      map[node.name] = this.mapNode(node);\n      if (node.op.startsWith('Placeholder')) {\n        placeholders.push(map[node.name]);\n      } else if (node.op === 'Const') {\n        weights.push(map[node.name]);\n      } else if (node.input == null || node.input.length === 0) {\n        initNodes.push(map[node.name]);\n      }\n      return map;\n    }, {});\n\n    let inputs: Node[] = [];\n    const outputs: Node[] = [];\n    let inputNodeNameToKey: {[key: string]: string} = {};\n    let outputNodeNameToKey: {[key: string]: string} = {};\n    if (signature != null) {\n      inputNodeNameToKey = this.mapSignatureEntries(signature.inputs);\n      outputNodeNameToKey = this.mapSignatureEntries(signature.outputs);\n    }\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName, , outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`;\n            // update the input name to use the mapped output index directly.\n            node.inputNames[index] = inputName;\n          }\n        }\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    });\n\n    // if signature has not outputs set, add any node that does not have\n    // outputs.\n    if (Object.keys(outputNodeNameToKey).length === 0) {\n      allNodes.forEach(key => {\n        const node = nodes[key];\n        if (node.children.length === 0) {\n          outputs.push(node);\n        }\n      });\n    } else {\n      Object.keys(outputNodeNameToKey).forEach(name => {\n        const [nodeName, ] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n        if (node != null) {\n          node.signatureKey = outputNodeNameToKey[name];\n          outputs.push(node);\n        }\n      });\n    }\n\n    if (Object.keys(inputNodeNameToKey).length > 0) {\n      Object.keys(inputNodeNameToKey).forEach(name => {\n        const [nodeName, ] = getNodeNameAndIndex(name);\n        const node = nodes[nodeName];\n        if (node) {\n          node.signatureKey = inputNodeNameToKey[name];\n          inputs.push(node);\n        }\n      });\n    } else {\n      inputs = placeholders;\n    }\n\n    let functions = {};\n    if (graph.library != null && graph.library.function != null) {\n      functions = graph.library.function.reduce((functions, func) => {\n        functions[func.signature.name] = this.mapFunction(func);\n        return functions;\n      }, {} as {[key: string]: Graph});\n    }\n\n    const result: Graph =\n        {nodes, inputs, outputs, weights, placeholders, signature, functions};\n\n    if (initNodes.length > 0) {\n      result.initNodes = initNodes;\n    }\n\n    return result;\n  }\n\n  private mapSignatureEntries(entries: {[k: string]: tensorflow.ITensorInfo}) {\n    return Object.keys(entries || {})\n        .reduce<{[key: string]: string}>((prev, curr) => {\n          prev[entries[curr].name] = curr;\n          return prev;\n        }, {});\n  }\n\n  private mapNode(node: tensorflow.INodeDef): Node {\n    // Unsupported ops will cause an error at run-time (not parse time), since\n    // they may not be used by the actual execution subgraph.\n    const mapper =\n        getRegisteredOp(node.op) || this.opMappers[node.op] || {} as OpMapper;\n    if (node.attr == null) {\n      node.attr = {};\n    }\n\n    const newNode: Node = {\n      name: node.name,\n      op: node.op,\n      category: mapper.category,\n      inputNames:\n          (node.input ||\n           []).map(input => input.startsWith('^') ? input.slice(1) : input),\n      inputs: [],\n      children: [],\n      inputParams: {},\n      attrParams: {},\n      rawAttrs: node.attr,\n      outputs: mapper.outputs\n    };\n\n    if (mapper.inputs != null) {\n      newNode.inputParams =\n          mapper.inputs.reduce<{[key: string]: InputParamValue}>(\n              (map, param) => {\n                map[param.name] = {\n                  type: param.type,\n                  inputIndexStart: param.start,\n                  inputIndexEnd: param.end\n                };\n                return map;\n              },\n              {});\n    }\n    if (mapper.attrs != null) {\n      newNode.attrParams =\n          mapper.attrs.reduce<{[key: string]: ParamValue}>((map, param) => {\n            const type = param.type;\n            let value = undefined;\n            switch (param.type) {\n              case 'string':\n                value = getStringParam(\n                    node.attr, param.tfName, param.defaultValue as string);\n\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getStringParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as string);\n                }\n                break;\n              case 'string[]':\n                value = getStringArrayParam(\n                    node.attr, param.tfName, param.defaultValue as string[]);\n\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getStringArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as string[]);\n                }\n                break;\n              case 'number':\n                value = getNumberParam(\n                    node.attr, param.tfName,\n                    (param.defaultValue || 0) as number);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getNumberParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number);\n                }\n                break;\n              case 'number[]':\n                value = getNumericArrayParam(\n                    node.attr, param.tfName, param.defaultValue as number[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getNumericArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number[]);\n                }\n                break;\n              case 'bool':\n                value = getBoolParam(\n                    node.attr, param.tfName, param.defaultValue as boolean);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getBoolParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as boolean);\n                }\n                break;\n              case 'bool[]':\n                value = getBoolArrayParam(\n                    node.attr, param.tfName, param.defaultValue as boolean[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getBoolArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as boolean[]);\n                }\n                break;\n              case 'shape':\n                value = getTensorShapeParam(\n                    node.attr, param.tfName, param.defaultValue as number[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getTensorShapeParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number[]);\n                }\n                break;\n              case 'shape[]':\n                value = getTensorShapeArrayParam(\n                    node.attr, param.tfName, param.defaultValue as number[][]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getTensorShapeArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as number[][]);\n                }\n                break;\n              case 'dtype':\n                value = getDtypeParam(\n                    node.attr, param.tfName, param.defaultValue as DataType);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getDtypeParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as DataType);\n                }\n                break;\n              case 'dtype[]':\n                value = getDtypeArrayParam(\n                    node.attr, param.tfName, param.defaultValue as DataType[]);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getDtypeArrayParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as DataType[]);\n                }\n                break;\n              case 'func':\n                value = getFuncParam(\n                    node.attr, param.tfName, param.defaultValue as string);\n                if (value === undefined && !!param.tfDeprecatedName) {\n                  value = getFuncParam(\n                      node.attr, param.tfDeprecatedName,\n                      param.defaultValue as string);\n                }\n                break;\n              case 'tensor':\n              case 'tensors':\n                break;\n              default:\n                throw new Error(\n                    `Unsupported param type: ${param.type} for op: ${node.op}`);\n            }\n            map[param.name] = {value, type};\n            return map;\n          }, {});\n    }\n    return newNode;\n  }\n\n  // map the TFunctionDef to TFJS graph object\n  private mapFunction(functionDef: tensorflow.IFunctionDef): Graph {\n    const tfNodes = functionDef.nodeDef;\n    const placeholders: Node[] = [];\n    const weights: Node[] = [];\n    let nodes: {[key: string]: Node} = {};\n    if (tfNodes != null) {\n      nodes = tfNodes.reduce<{[key: string]: Node}>((map, node) => {\n        map[node.name] = this.mapNode(node);\n        if (node.op === 'Const') {\n          weights.push(map[node.name]);\n        }\n        return map;\n      }, {});\n    }\n    const inputs: Node[] = [];\n    const outputs: Node[] = [];\n\n    functionDef.signature.inputArg.forEach(arg => {\n      const [nodeName, ] = getNodeNameAndIndex(arg.name);\n      const node: Node = {\n        name: nodeName,\n        op: 'Placeholder',\n        inputs: [],\n        inputNames: [],\n        category: 'graph',\n        inputParams: {},\n        attrParams: {dtype: {value: parseDtypeParam(arg.type), type: 'dtype'}},\n        children: []\n      };\n      node.signatureKey = arg.name;\n      inputs.push(node);\n      nodes[nodeName] = node;\n    });\n\n    const allNodes = Object.keys(nodes);\n    allNodes.forEach(key => {\n      const node = nodes[key];\n      node.inputNames.forEach((name, index) => {\n        const [nodeName, , outputName] = getNodeNameAndIndex(name);\n        const inputNode = nodes[nodeName];\n        if (inputNode.outputs != null) {\n          const outputIndex = inputNode.outputs.indexOf(outputName);\n          if (outputIndex !== -1) {\n            const inputName = `${nodeName}:${outputIndex}`;\n            // update the input name to use the mapped output index directly.\n            node.inputNames[index] = inputName;\n          }\n        }\n        node.inputs.push(inputNode);\n        inputNode.children.push(node);\n      });\n    });\n\n    const returnNodeMap = functionDef.ret;\n\n    functionDef.signature.outputArg.forEach(output => {\n      const [nodeName, index] = getNodeNameAndIndex(returnNodeMap[output.name]);\n      const node = nodes[nodeName];\n      if (node != null) {\n        node.defaultOutput = index;\n        outputs.push(node);\n      }\n    });\n\n    const signature = this.mapArgsToSignature(functionDef);\n    return {nodes, inputs, outputs, weights, placeholders, signature};\n  }\n\n  private mapArgsToSignature(functionDef: tensorflow.IFunctionDef):\n      tensorflow.ISignatureDef {\n    return {\n      methodName: functionDef.signature.name,\n      inputs: functionDef.signature.inputArg.reduce(\n          (map, arg) => {\n            map[arg.name] = this.mapArgToTensorInfo(arg);\n            return map;\n          },\n          {} as {[key: string]: tensorflow.ITensorInfo}),\n      outputs: functionDef.signature.outputArg.reduce(\n          (map, arg) => {\n            map[arg.name] = this.mapArgToTensorInfo(arg, functionDef.ret);\n            return map;\n          },\n          {} as {[key: string]: tensorflow.ITensorInfo}),\n    };\n  }\n\n  private mapArgToTensorInfo(\n      arg: tensorflow.OpDef.IArgDef,\n      nameMap?: {[key: string]: string}): tensorflow.ITensorInfo {\n    let name = arg.name;\n    if (nameMap != null) {\n      name = nameMap[name];\n    }\n    return {name, dtype: arg.type};\n  }\n}\n\nexport function decodeBase64(text: string): string {\n  const global = env().global;\n  if (typeof global.atob !== 'undefined') {\n    return global.atob(text);\n  } else if (typeof Buffer !== 'undefined') {\n    return new Buffer(text, 'base64').toString();\n  } else {\n    throw new Error(\n        'Unable to decode base64 in this environment. ' +\n        'Missing built-in atob() or Buffer()');\n  }\n}\n\nexport function parseStringParam(s: []|string, keepCase: boolean): string {\n  const value =\n      Array.isArray(s) ? String.fromCharCode.apply(null, s) : decodeBase64(s);\n  return keepCase ? value : value.toLowerCase();\n}\n\nexport function getStringParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string, def: string,\n    keepCase = false): string {\n  const param = attrs[name];\n  if (param != null) {\n    return parseStringParam(param.s, keepCase);\n  }\n  return def;\n}\n\nexport function getBoolParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: boolean): boolean {\n  const param = attrs[name];\n  return param ? param.b : def;\n}\n\nexport function getNumberParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: number): number {\n  const param = attrs[name] || {};\n  const value =\n      param['i'] != null ? param['i'] : (param['f'] != null ? param['f'] : def);\n  return (typeof value === 'number') ? value : parseInt(value, 10);\n}\n\nexport function parseDtypeParam(value: string|tensorflow.DataType): DataType {\n  if (typeof (value) === 'string') {\n    // tslint:disable-next-line:no-any\n    value = tensorflow.DataType[value as any];\n  }\n  switch (value) {\n    case tensorflow.DataType.DT_FLOAT:\n    case tensorflow.DataType.DT_HALF:\n      return 'float32';\n    case tensorflow.DataType.DT_INT32:\n    case tensorflow.DataType.DT_INT64:\n    case tensorflow.DataType.DT_INT8:\n    case tensorflow.DataType.DT_UINT8:\n      return 'int32';\n    case tensorflow.DataType.DT_BOOL:\n      return 'bool';\n    case tensorflow.DataType.DT_DOUBLE:\n      return 'float32';\n    case tensorflow.DataType.DT_STRING:\n      return 'string';\n    case tensorflow.DataType.DT_COMPLEX64:\n    case tensorflow.DataType.DT_COMPLEX128:\n      return 'complex64';\n    default:\n      // Unknown dtype error will happen at runtime (instead of parse time),\n      // since these nodes might not be used by the actual subgraph execution.\n      return null;\n  }\n}\n\nexport function getFuncParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: string): string {\n  const param = attrs[name];\n  if (param && param.func) {\n    return param.func.name;\n  }\n  return def;\n}\n\nexport function getDtypeParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: DataType): DataType {\n  const param = attrs[name];\n  if (param && param.type) {\n    return parseDtypeParam(param.type);\n  }\n  return def;\n}\n\nexport function getDtypeArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: DataType[]): DataType[] {\n  const param = attrs[name];\n  if (param && param.list && param.list.type) {\n    return param.list.type.map(v => parseDtypeParam(v));\n  }\n  return def;\n}\n\nexport function parseTensorShapeParam(shape: tensorflow.ITensorShape): number[]|\n    undefined {\n  if (shape.unknownRank) {\n    return undefined;\n  }\n  if (shape.dim != null) {\n    return shape.dim.map(\n        dim =>\n            (typeof dim.size === 'number') ? dim.size : parseInt(dim.size, 10));\n  }\n  return [];\n}\n\nexport function getTensorShapeParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def?: number[]): number[]|undefined {\n  const param = attrs[name];\n  if (param && param.shape) {\n    return parseTensorShapeParam(param.shape);\n  }\n  return def;\n}\n\nexport function getNumericArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: number[]): number[] {\n  const param = attrs[name];\n  if (param) {\n    return ((param.list.f && param.list.f.length ? param.list.f :\n                                                   param.list.i) ||\n            [])\n        .map(v => (typeof v === 'number') ? v : parseInt(v, 10));\n  }\n  return def;\n}\n\nexport function getStringArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string, def: string[],\n    keepCase = false): string[] {\n  const param = attrs[name];\n  if (param && param.list && param.list.s) {\n    return param.list.s.map((v) => {\n      return parseStringParam(v, keepCase);\n    });\n  }\n  return def;\n}\n\nexport function getTensorShapeArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: number[][]): number[][] {\n  const param = attrs[name];\n  if (param && param.list && param.list.shape) {\n    return param.list.shape.map((v) => {\n      return parseTensorShapeParam(v);\n    });\n  }\n  return def;\n}\n\nexport function getBoolArrayParam(\n    attrs: {[key: string]: tensorflow.IAttrValue}, name: string,\n    def: boolean[]): boolean[] {\n  const param = attrs[name];\n  if (param && param.list && param.list.b) {\n    return param.list.b;\n  }\n  return def;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}