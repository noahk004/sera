{"ast":null,"code":"/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { convertToTensor } from '../../tensor_util_env';\nimport * as util from '../../util';\nimport { cast } from '../cast';\nimport { einsum } from '../einsum';\nimport { expandDims } from '../expand_dims';\nimport { op } from '../operation';\nimport { tensor1d } from '../tensor1d';\n/**\n * Converts images from RGB format to grayscale.\n *\n * @param image A RGB tensor to convert. The `image`'s last dimension must\n *     be size 3 with at least a two-dimensional shape.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction rgbToGrayscale_(image) {\n  const $image = convertToTensor(image, 'image', 'RGBToGrayscale');\n  const lastDimsIdx = $image.rank - 1;\n  const lastDims = $image.shape[lastDimsIdx];\n  util.assert($image.rank >= 2, () => 'Error in RGBToGrayscale: images must be at least rank 2, ' + `but got rank ${$image.rank}.`);\n  util.assert(lastDims === 3, () => 'Error in RGBToGrayscale: last dimension of an RGB image ' + `should be size 3, but got size ${lastDims}.`);\n  // Remember original dtype so we can convert back if needed\n  const origDtype = $image.dtype;\n  const fltImage = cast($image, 'float32');\n  const rgbWeights = tensor1d([0.2989, 0.5870, 0.1140]);\n  let grayFloat;\n  switch ($image.rank) {\n    case 2:\n      grayFloat = einsum('ij,j->i', fltImage, rgbWeights);\n      break;\n    case 3:\n      grayFloat = einsum('ijk,k->ij', fltImage, rgbWeights);\n      break;\n    case 4:\n      grayFloat = einsum('ijkl,l->ijk', fltImage, rgbWeights);\n      break;\n    case 5:\n      grayFloat = einsum('ijklm,m->ijkl', fltImage, rgbWeights);\n      break;\n    case 6:\n      grayFloat = einsum('ijklmn,n->ijklm', fltImage, rgbWeights);\n      break;\n    default:\n      throw new Error('Not a valid tensor rank.');\n  }\n  grayFloat = expandDims(grayFloat, -1);\n  return cast(grayFloat, origDtype);\n}\nexport const rgbToGrayscale = /* @__PURE__ */op({\n  rgbToGrayscale_\n});","map":{"version":3,"sources":["../../../../../../../tfjs-core/src/ops/image/rgb_to_grayscale.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAGH,SAAQ,eAAe,QAAO,uBAAuB;AAErD,OAAO,KAAK,IAAI,MAAM,YAAY;AAClC,SAAQ,IAAI,QAAO,SAAS;AAC5B,SAAQ,MAAM,QAAO,WAAW;AAChC,SAAQ,UAAU,QAAO,gBAAgB;AACzC,SAAQ,EAAE,QAAO,cAAc;AAC/B,SAAQ,QAAQ,QAAO,aAAa;AAEpC;;;;;;;AAOG;AACH,SAAS,eAAe,CACW,KAAmB,EAAA;EACpD,MAAM,MAAM,GAAG,eAAe,CAAC,KAAK,EAAE,OAAO,EAAE,gBAAgB,CAAC;EAEhE,MAAM,WAAW,GAAG,MAAM,CAAC,IAAI,GAAG,CAAC;EACnC,MAAM,QAAQ,GAAG,MAAM,CAAC,KAAK,CAAC,WAAW,CAAC;EAE1C,IAAI,CAAC,MAAM,CACP,MAAM,CAAC,IAAI,IAAI,CAAC,EAChB,MAAM,2DAA2D,GAC7D,gBAAgB,MAAM,CAAC,IAAI,GAAG,CAAC;EAEvC,IAAI,CAAC,MAAM,CACP,QAAQ,KAAK,CAAC,EACd,MAAM,0DAA0D,GAC5D,kCAAkC,QAAQ,GAAG,CAAC;EAEtD;EACA,MAAM,SAAS,GAAG,MAAM,CAAC,KAAK;EAC9B,MAAM,QAAQ,GAAG,IAAI,CAAC,MAAM,EAAE,SAAS,CAAC;EAExC,MAAM,UAAU,GAAG,QAAQ,CAAC,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;EAErD,IAAI,SAAS;EACb,QAAQ,MAAM,CAAC,IAAI;IACjB,KAAK,CAAC;MACJ,SAAS,GAAG,MAAM,CAAC,SAAS,EAAE,QAAQ,EAAE,UAAU,CAAC;MACnD;IACF,KAAK,CAAC;MACJ,SAAS,GAAG,MAAM,CAAC,WAAW,EAAE,QAAQ,EAAE,UAAU,CAAC;MACrD;IACF,KAAK,CAAC;MACJ,SAAS,GAAG,MAAM,CAAC,aAAa,EAAE,QAAQ,EAAE,UAAU,CAAC;MACvD;IACF,KAAK,CAAC;MACJ,SAAS,GAAG,MAAM,CAAC,eAAe,EAAE,QAAQ,EAAE,UAAU,CAAC;MACzD;IACF,KAAK,CAAC;MACJ,SAAS,GAAG,MAAM,CAAC,iBAAiB,EAAE,QAAQ,EAAE,UAAU,CAAC;MAC3D;IACF;MACE,MAAM,IAAI,KAAK,CAAC,0BAA0B,CAAC;EAC9C;EACD,SAAS,GAAG,UAAU,CAAC,SAAS,EAAE,CAAC,CAAC,CAAC;EAErC,OAAO,IAAI,CAAC,SAAS,EAAE,SAAS,CAAM;AACxC;AAEA,OAAO,MAAM,cAAc,GAAG,eAAgB,EAAE,CAAC;EAAC;AAAe,CAAC,CAAC","sourcesContent":["/**\n * @license\n * Copyright 2023 Google LLC.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {Tensor2D, Tensor3D, Tensor4D, Tensor5D, Tensor6D} from '../../tensor';\nimport {convertToTensor} from '../../tensor_util_env';\nimport {TensorLike} from '../../types';\nimport * as util from '../../util';\nimport {cast} from '../cast';\nimport {einsum} from '../einsum';\nimport {expandDims} from '../expand_dims';\nimport {op} from '../operation';\nimport {tensor1d} from '../tensor1d';\n\n/**\n * Converts images from RGB format to grayscale.\n *\n * @param image A RGB tensor to convert. The `image`'s last dimension must\n *     be size 3 with at least a two-dimensional shape.\n *\n * @doc {heading: 'Operations', subheading: 'Images', namespace: 'image'}\n */\nfunction rgbToGrayscale_<T extends Tensor2D|Tensor3D|Tensor4D|Tensor5D|\n                         Tensor6D>(image: T|TensorLike): T {\n  const $image = convertToTensor(image, 'image', 'RGBToGrayscale');\n\n  const lastDimsIdx = $image.rank - 1;\n  const lastDims = $image.shape[lastDimsIdx];\n\n  util.assert(\n      $image.rank >= 2,\n      () => 'Error in RGBToGrayscale: images must be at least rank 2, ' +\n          `but got rank ${$image.rank}.`);\n\n  util.assert(\n      lastDims === 3,\n      () => 'Error in RGBToGrayscale: last dimension of an RGB image ' +\n          `should be size 3, but got size ${lastDims}.`);\n\n  // Remember original dtype so we can convert back if needed\n  const origDtype = $image.dtype;\n  const fltImage = cast($image, 'float32');\n\n  const rgbWeights = tensor1d([0.2989, 0.5870, 0.1140]);\n\n  let grayFloat;\n  switch ($image.rank) {\n    case 2:\n      grayFloat = einsum('ij,j->i', fltImage, rgbWeights);\n      break;\n    case 3:\n      grayFloat = einsum('ijk,k->ij', fltImage, rgbWeights);\n      break;\n    case 4:\n      grayFloat = einsum('ijkl,l->ijk', fltImage, rgbWeights);\n      break;\n    case 5:\n      grayFloat = einsum('ijklm,m->ijkl', fltImage, rgbWeights);\n      break;\n    case 6:\n      grayFloat = einsum('ijklmn,n->ijklm', fltImage, rgbWeights);\n      break;\n    default:\n      throw new Error('Not a valid tensor rank.');\n  }\n  grayFloat = expandDims(grayFloat, -1);\n\n  return cast(grayFloat, origDtype) as T;\n}\n\nexport const rgbToGrayscale = /* @__PURE__ */ op({rgbToGrayscale_});\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}