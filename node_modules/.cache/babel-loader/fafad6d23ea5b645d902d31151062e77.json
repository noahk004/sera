{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, sumOutType, UnsortedSegmentSum, util } from '@tensorflow/tfjs-core';\nimport { SegmentOpProgram } from '../segment_gpu';\nimport { range } from './Range';\nimport { reshape } from './Reshape';\nimport { tile } from './Tile';\nimport { transpose } from './Transpose';\nexport function unsortedSegmentSum(args) {\n  const {\n    inputs,\n    backend,\n    attrs\n  } = args;\n  const {\n    x,\n    segmentIds\n  } = inputs;\n  const {\n    numSegments\n  } = attrs;\n  const xRank = x.shape.length;\n  const toDispose = [];\n  let axis = 0;\n  const permutation = backend_util.getAxesPermutation([axis], xRank);\n  let permutedX = x;\n  if (permutation != null) {\n    permutedX = transpose({\n      inputs: {\n        x\n      },\n      backend,\n      attrs: {\n        perm: permutation\n      }\n    });\n    toDispose.push(permutedX);\n    axis = backend_util.getInnerMostAxes(1, xRank)[0];\n  }\n  const outShape = backend_util.segment_util.computeOutShape(permutedX.shape, axis, numSegments);\n  const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n  const a2D = reshape({\n    inputs: {\n      x: permutedX\n    },\n    backend,\n    attrs: {\n      shape: [-1, inSize]\n    }\n  });\n  toDispose.push(a2D);\n  const outputDType = sumOutType(x.dtype);\n  const segOpCompute = (x, segOpType, segmentIds, dtype, numSegments) => {\n    const batchSize = x.shape[0];\n    const inSize = x.shape[1];\n    const windowSize = backend_util.segment_util.segOpComputeOptimalWindowSize(inSize, numSegments);\n    const segOpInfo = {\n      windowSize,\n      inSize,\n      batchSize,\n      numSegments\n    };\n    const program = new SegmentOpProgram(segOpInfo, segOpType);\n    const output = backend.compileAndRun(program, [x, segmentIds], dtype);\n    toDispose.push(output);\n    // No need to run another GPGPU program.\n    if (output.shape[1] === numSegments) {\n      return output;\n    }\n    const rangeInfo = range({\n      backend,\n      attrs: {\n        start: 0,\n        stop: numSegments,\n        step: 1,\n        dtype: 'float32'\n      }\n    });\n    const tileInfo = tile({\n      inputs: {\n        x: rangeInfo\n      },\n      backend,\n      attrs: {\n        reps: [inSize / windowSize]\n      }\n    });\n    toDispose.push(rangeInfo);\n    toDispose.push(tileInfo);\n    const result = segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n    return result;\n  };\n  const segOpResult = segOpCompute(a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n  const reshaped = reshape({\n    inputs: {\n      x: segOpResult\n    },\n    backend,\n    attrs: {\n      shape: outShape\n    }\n  });\n  let result = reshaped;\n  if (permutation != null) {\n    toDispose.push(reshaped);\n    const perm = backend_util.getUndoAxesPermutation(permutation);\n    result = transpose({\n      inputs: {\n        x: result\n      },\n      backend,\n      attrs: {\n        perm\n      }\n    });\n  }\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\nexport const unsortedSegmentSumConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'webgl',\n  kernelFunc: unsortedSegmentSum\n};","map":{"version":3,"sources":["../../../../../../tfjs-backend-webgl/src/kernels/UnsortedSegmentSum.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;AAeG;AAEH,SAAQ,YAAY,EAAsC,UAAU,EAAc,kBAAkB,EAAqD,IAAI,QAAO,uBAAuB;AAG3L,SAAQ,gBAAgB,QAAO,gBAAgB;AAE/C,SAAQ,KAAK,QAAO,SAAS;AAC7B,SAAQ,OAAO,QAAO,WAAW;AACjC,SAAQ,IAAI,QAAO,QAAQ;AAC3B,SAAQ,SAAS,QAAO,aAAa;AAErC,OAAM,SAAU,kBAAkB,CAAC,IAIlC,EAAA;EACC,MAAM;IAAC,MAAM;IAAE,OAAO;IAAE;EAAK,CAAC,GAAG,IAAI;EACrC,MAAM;IAAC,CAAC;IAAE;EAAU,CAAC,GAAG,MAAM;EAC9B,MAAM;IAAC;EAAW,CAAC,GAAG,KAAK;EAE3B,MAAM,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,MAAM;EAE5B,MAAM,SAAS,GAAG,EAAE;EAEpB,IAAI,IAAI,GAAG,CAAC;EACZ,MAAM,WAAW,GAAG,YAAY,CAAC,kBAAkB,CAAC,CAAC,IAAI,CAAC,EAAE,KAAK,CAAC;EAClE,IAAI,SAAS,GAAG,CAAC;EACjB,IAAI,WAAW,IAAI,IAAI,EAAE;IACvB,SAAS,GAAG,SAAS,CAAC;MAAC,MAAM,EAAE;QAAC;MAAC,CAAC;MAAE,OAAO;MAAE,KAAK,EAAE;QAAC,IAAI,EAAE;MAAW;IAAC,CAAC,CAAC;IACzE,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC;IACzB,IAAI,GAAG,YAAY,CAAC,gBAAgB,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC,CAAC;EAClD;EAED,MAAM,QAAQ,GAAG,YAAY,CAAC,YAAY,CAAC,eAAe,CACtD,SAAS,CAAC,KAAK,EAAE,IAAI,EAAE,WAAW,CAAC;EACvC,MAAM,MAAM,GAAG,IAAI,CAAC,aAAa,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC;EAC1D,MAAM,GAAG,GACL,OAAO,CAAC;IAAC,MAAM,EAAE;MAAC,CAAC,EAAE;IAAS,CAAC;IAAE,OAAO;IAAE,KAAK,EAAE;MAAC,KAAK,EAAE,CAAC,CAAC,CAAC,EAAE,MAAM;IAAC;EAAC,CAAC,CAAC;EAC5E,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC;EAEnB,MAAM,WAAW,GAAG,UAAU,CAAC,CAAC,CAAC,KAAK,CAAC;EAEvC,MAAM,YAAY,GACd,CAAC,CAAa,EAAE,SAA+B,EAAE,UAAsB,EACtE,KAAe,EAAE,WAAmB,KAAgB;IACnD,MAAM,SAAS,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;IAC5B,MAAM,MAAM,GAAG,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;IACzB,MAAM,UAAU,GACZ,YAAY,CAAC,YAAY,CAAC,6BAA6B,CACnD,MAAM,EAAE,WAAW,CAAC;IAC5B,MAAM,SAAS,GAAG;MAAC,UAAU;MAAE,MAAM;MAAE,SAAS;MAAE;IAAW,CAAC;IAC9D,MAAM,OAAO,GAAG,IAAI,gBAAgB,CAAC,SAAS,EAAE,SAAS,CAAC;IAC1D,MAAM,MAAM,GAAG,OAAO,CAAC,aAAa,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,UAAU,CAAC,EAAE,KAAK,CAAC;IACrE,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC;IACtB;IACA,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC,KAAK,WAAW,EAAE;MACnC,OAAO,MAAM;IACd;IACD,MAAM,SAAS,GAAG,KAAK,CAAC;MACtB,OAAO;MACP,KAAK,EAAE;QAAC,KAAK,EAAE,CAAC;QAAE,IAAI,EAAE,WAAW;QAAE,IAAI,EAAE,CAAC;QAAE,KAAK,EAAE;MAAS;KAC/D,CAAC;IACF,MAAM,QAAQ,GAAG,IAAI,CAAC;MACpB,MAAM,EAAE;QAAC,CAAC,EAAE;MAAS,CAAC;MACtB,OAAO;MACP,KAAK,EAAE;QAAC,IAAI,EAAE,CAAC,MAAM,GAAG,UAAU;MAAC;KACpC,CAAC;IAEF,SAAS,CAAC,IAAI,CAAC,SAAS,CAAC;IACzB,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC;IAExB,MAAM,MAAM,GACR,YAAY,CAAC,MAAM,EAAE,SAAS,EAAE,QAAQ,EAAE,KAAK,EAAE,WAAW,CAAC;IACjE,OAAO,MAAM;EACf,CAAC;EAEL,MAAM,WAAW,GAAG,YAAY,CAC5B,GAAG,EAAE,oBAAoB,EAAE,UAAU,EAAE,WAAW,EAAE,WAAW,CAAC;EAEpE,MAAM,QAAQ,GACV,OAAO,CAAC;IAAC,MAAM,EAAE;MAAC,CAAC,EAAE;IAAW,CAAC;IAAE,OAAO;IAAE,KAAK,EAAE;MAAC,KAAK,EAAE;IAAQ;EAAC,CAAC,CAAC;EAE1E,IAAI,MAAM,GAAG,QAAQ;EACrB,IAAI,WAAW,IAAI,IAAI,EAAE;IACvB,SAAS,CAAC,IAAI,CAAC,QAAQ,CAAC;IACxB,MAAM,IAAI,GAAG,YAAY,CAAC,sBAAsB,CAAC,WAAW,CAAC;IAC7D,MAAM,GAAG,SAAS,CAAC;MAAC,MAAM,EAAE;QAAC,CAAC,EAAE;MAAM,CAAC;MAAE,OAAO;MAAE,KAAK,EAAE;QAAC;MAAI;IAAC,CAAC,CAAC;EAClE;EAED,SAAS,CAAC,OAAO,CAAC,CAAC,IAAI,OAAO,CAAC,6BAA6B,CAAC,CAAC,CAAC,CAAC;EAChE,OAAO,MAAM;AACf;AAEA,OAAO,MAAM,wBAAwB,GAAiB;EACpD,UAAU,EAAE,kBAAkB;EAC9B,WAAW,EAAE,OAAO;EACpB,UAAU,EAAE;CACb","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, KernelConfig, KernelFunc, sumOutType, TensorInfo, UnsortedSegmentSum, UnsortedSegmentSumAttrs, UnsortedSegmentSumInputs, util} from '@tensorflow/tfjs-core';\n\nimport {MathBackendWebGL} from '../backend_webgl';\nimport {SegmentOpProgram} from '../segment_gpu';\n\nimport {range} from './Range';\nimport {reshape} from './Reshape';\nimport {tile} from './Tile';\nimport {transpose} from './Transpose';\n\nexport function unsortedSegmentSum(args: {\n  inputs: UnsortedSegmentSumInputs,\n  backend: MathBackendWebGL,\n  attrs: UnsortedSegmentSumAttrs\n}): TensorInfo {\n  const {inputs, backend, attrs} = args;\n  const {x, segmentIds} = inputs;\n  const {numSegments} = attrs;\n\n  const xRank = x.shape.length;\n\n  const toDispose = [];\n\n  let axis = 0;\n  const permutation = backend_util.getAxesPermutation([axis], xRank);\n  let permutedX = x;\n  if (permutation != null) {\n    permutedX = transpose({inputs: {x}, backend, attrs: {perm: permutation}});\n    toDispose.push(permutedX);\n    axis = backend_util.getInnerMostAxes(1, xRank)[0];\n  }\n\n  const outShape = backend_util.segment_util.computeOutShape(\n      permutedX.shape, axis, numSegments);\n  const inSize = util.sizeFromShape([permutedX.shape[axis]]);\n  const a2D =\n      reshape({inputs: {x: permutedX}, backend, attrs: {shape: [-1, inSize]}});\n  toDispose.push(a2D);\n\n  const outputDType = sumOutType(x.dtype);\n\n  const segOpCompute =\n      (x: TensorInfo, segOpType: 'unsortedSegmentSum', segmentIds: TensorInfo,\n       dtype: DataType, numSegments: number): TensorInfo => {\n        const batchSize = x.shape[0];\n        const inSize = x.shape[1];\n        const windowSize =\n            backend_util.segment_util.segOpComputeOptimalWindowSize(\n                inSize, numSegments);\n        const segOpInfo = {windowSize, inSize, batchSize, numSegments};\n        const program = new SegmentOpProgram(segOpInfo, segOpType);\n        const output = backend.compileAndRun(program, [x, segmentIds], dtype);\n        toDispose.push(output);\n        // No need to run another GPGPU program.\n        if (output.shape[1] === numSegments) {\n          return output;\n        }\n        const rangeInfo = range({\n          backend,\n          attrs: {start: 0, stop: numSegments, step: 1, dtype: 'float32'}\n        });\n        const tileInfo = tile({\n          inputs: {x: rangeInfo},\n          backend,\n          attrs: {reps: [inSize / windowSize]}\n        });\n\n        toDispose.push(rangeInfo);\n        toDispose.push(tileInfo);\n\n        const result =\n            segOpCompute(output, segOpType, tileInfo, dtype, numSegments);\n        return result;\n      };\n\n  const segOpResult = segOpCompute(\n      a2D, 'unsortedSegmentSum', segmentIds, outputDType, numSegments);\n\n  const reshaped =\n      reshape({inputs: {x: segOpResult}, backend, attrs: {shape: outShape}});\n\n  let result = reshaped;\n  if (permutation != null) {\n    toDispose.push(reshaped);\n    const perm = backend_util.getUndoAxesPermutation(permutation);\n    result = transpose({inputs: {x: result}, backend, attrs: {perm}});\n  }\n\n  toDispose.forEach(t => backend.disposeIntermediateTensorInfo(t));\n  return result;\n}\n\nexport const unsortedSegmentSumConfig: KernelConfig = {\n  kernelName: UnsortedSegmentSum,\n  backendName: 'webgl',\n  kernelFunc: unsortedSegmentSum as {} as KernelFunc\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}