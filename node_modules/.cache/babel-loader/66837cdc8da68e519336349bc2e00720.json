{"ast":null,"code":"/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport * as util from '../util';\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\nexport function computeDilation2DInfo(inputShape, filterShape, strides, pad, dataFormat = 'NHWC', dilations) {\n  // `computerConv2DInfo` require filterShape to be in the dimension of:\n  // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n  // outDepth, it should have the same depth as the input.\n  // Input shape: [batch, height, width, inChannels]\n  const inputChannels = inputShape[3];\n  const $filterShape = [...filterShape, inputChannels];\n  const $dataFormat = convertConv2DDataFormat(dataFormat);\n  return computeConv2DInfo(inputShape, $filterShape, strides, dilations, pad, null /* roundingMode */, null /* depthWise */, $dataFormat);\n}\nexport function computePool2DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'channelsLast') {\n  const [filterHeight, filterWidth] = parseTupleParam(filterSize);\n  let filterShape;\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n  return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);\n}\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\nexport function computePool3DInfo(inShape, filterSize, strides, dilations, pad, roundingMode, dataFormat = 'NDHWC') {\n  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);\n  let filterShape;\n  let $dataFormat;\n  if (dataFormat === 'NDHWC') {\n    $dataFormat = 'channelsLast';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n  } else if (dataFormat === 'NCDHW') {\n    $dataFormat = 'channelsFirst';\n    filterShape = [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n  return computeConv3DInfo(inShape, filterShape, strides, dilations, pad, false, $dataFormat, roundingMode);\n}\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\nexport function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise = false, dataFormat = 'channelsLast') {\n  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n  const [filterHeight, filterWidth,, filterChannels] = filterShape;\n  const [strideHeight, strideWidth] = parseTupleParam(strides);\n  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);\n  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {\n    padInfo,\n    outHeight,\n    outWidth\n  } = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode, dataFormat);\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  let outShape;\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n  return {\n    batchSize,\n    dataFormat,\n    inHeight,\n    inWidth,\n    inChannels,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideHeight,\n    strideWidth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\nexport function computeConv3DInfo(inShape, filterShape, strides, dilations, pad, depthwise = false, dataFormat = 'channelsLast', roundingMode) {\n  let [batchSize, inDepth, inHeight, inWidth, inChannels] = [-1, -1, -1, -1, -1];\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n  const [filterDepth, filterHeight, filterWidth,, filterChannels] = filterShape;\n  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);\n  const [dilationDepth, dilationHeight, dilationWidth] = parse3TupleParam(dilations);\n  const effectiveFilterDepth = getEffectiveFilterSize(filterDepth, dilationDepth);\n  const effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {\n    padInfo,\n    outDepth,\n    outHeight,\n    outWidth\n  } = get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth, roundingMode);\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n  let outShape;\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n  }\n  return {\n    batchSize,\n    dataFormat,\n    inDepth,\n    inHeight,\n    inWidth,\n    inChannels,\n    outDepth,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideDepth,\n    strideHeight,\n    strideWidth,\n    filterDepth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterDepth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationDepth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\nfunction computeOutputShape2D(inShape, fieldSize, stride, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n  const inputRows = inShape[0];\n  const inputCols = inShape[1];\n  const outputRows = round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols = round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  return [outputRows, outputCols];\n}\nfunction computeOutputShape4D(inShape, filterShape, outChannels, strides, zeroPad, roundingMode) {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);\n  }\n  const outShape = [0, 0, 0, outChannels];\n  for (let index = 0; index < 3; index++) {\n    if (inShape[index] + 2 * zeroPad >= filterShape[index]) {\n      outShape[index] = round((inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] + 1, roundingMode);\n    }\n  }\n  return outShape;\n}\nexport function computeDefaultPad(inputShape, fieldSize, stride, dilation = 1) {\n  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor((inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\nfunction parseTupleParam(param) {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n  return param;\n}\nfunction parse3TupleParam(param) {\n  return typeof param === 'number' ? [param, param, param] : param;\n}\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\nfunction getEffectiveFilterSize(filterSize, dilation) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\nfunction getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode, dataFormat) {\n  let padInfo;\n  let outHeight;\n  let outWidth;\n  if (typeof pad === 'number') {\n    const padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      type: padType\n    };\n    const outShape = computeOutputShape2D([inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongHeight = Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n    const padAlongWidth = Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n    padInfo = {\n      top,\n      bottom,\n      left,\n      right,\n      type: 'SAME'\n    };\n  } else if (pad === 'valid') {\n    padInfo = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      type: 'VALID'\n    };\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else if (typeof pad === 'object') {\n    const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n    const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n    const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n    const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n    const padType = top === 0 && bottom === 0 && left === 0 && right === 0 ? 'VALID' : 'EXPLICIT';\n    padInfo = {\n      top,\n      bottom,\n      left,\n      right,\n      type: padType\n    };\n    outHeight = round((inHeight - filterHeight + top + bottom) / strideHeight + 1, roundingMode);\n    outWidth = round((inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n  return {\n    padInfo,\n    outHeight,\n    outWidth\n  };\n}\nfunction get3DPadAndOutInfo(pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth, filterDepth, filterHeight, filterWidth, roundingMode) {\n  let padInfo;\n  let outDepth;\n  let outHeight;\n  let outWidth;\n  if (pad === 'valid') {\n    pad = 0;\n  }\n  if (typeof pad === 'number') {\n    const padType = pad === 0 ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      front: pad,\n      back: pad,\n      type: padType\n    };\n    const outShape = computeOutputShape4D([inDepth, inHeight, inWidth, 1], [filterDepth, filterHeight, filterWidth], 1, [strideDepth, strideHeight, strideWidth], pad, roundingMode);\n    outDepth = outShape[0];\n    outHeight = outShape[1];\n    outWidth = outShape[2];\n  } else if (pad === 'same') {\n    outDepth = Math.ceil(inDepth / strideDepth);\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n    const padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    const front = Math.floor(padAlongDepth / 2);\n    const back = padAlongDepth - front;\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n    padInfo = {\n      top,\n      bottom,\n      left,\n      right,\n      front,\n      back,\n      type: 'SAME'\n    };\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n  return {\n    padInfo,\n    outDepth,\n    outHeight,\n    outWidth\n  };\n}\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction round(value, roundingMode) {\n  if (!roundingMode) {\n    return Math.trunc(value);\n  }\n  switch (roundingMode) {\n    case 'round':\n      // used for Caffe Conv\n      return Math.round(value);\n    case 'ceil':\n      // used for Caffe Pool\n      return Math.ceil(value);\n    case 'floor':\n      return Math.floor(value);\n    default:\n      throw new Error(`Unknown roundingMode ${roundingMode}`);\n  }\n}\nexport function tupleValuesAreOne(param) {\n  const [dimA, dimB, dimC] = parseTupleParam(param);\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\nexport function eitherStridesOrDilationsAreOne(strides, dilations) {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\nexport function stridesOrDilationsArePositive(values) {\n  return parseTupleParam(values).every(value => value > 0);\n}\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\nexport function convertConv2DDataFormat(dataFormat) {\n  if (dataFormat === 'NHWC') {\n    return 'channelsLast';\n  } else if (dataFormat === 'NCHW') {\n    return 'channelsFirst';\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n}\n/**\n * Check validity of pad when using dimRoundingMode.\n * @param opDesc A string of op description\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid` output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @throws unknown padding parameter\n */\nexport function checkPadOnDimRoundingMode(opDesc, pad, dimRoundingMode) {\n  if (dimRoundingMode != null) {\n    if (typeof pad === 'string') {\n      throw Error(`Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'number') {\n      util.assert(util.isInt(pad), () => `Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'object') {\n      pad.forEach(p => {\n        p.forEach(v => {\n          util.assert(util.isInt(v), () => `Error in ${opDesc}: pad must be an integer when using ` + `dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);\n        });\n      });\n    } else {\n      throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad}`);\n    }\n  }\n}","map":{"version":3,"sources":["../../../../../../tfjs-core/src/ops/conv_util.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport * as util from '../util';\n\ntype PadType = 'SAME'|'VALID'|'NUMBER'|'EXPLICIT';\n\n// For NHWC should be in the following form:\n//  [[0, 0], [pad_top,pad_bottom], [pad_left, pad_right], [0, 0]]\n// For NCHW should be in the following form:\n//  [[0, 0], [0, 0], [pad_top,pad_bottom], [pad_left, pad_right]]\n// Reference: https://www.tensorflow.org/api_docs/python/tf/nn/conv2d\nexport type ExplicitPadding =\n    [[number, number], [number, number], [number, number], [number, number]];\n\nexport type PadInfo = {\n  top: number,\n  left: number,\n  right: number,\n  bottom: number,\n  type: PadType\n};\n\nexport type PadInfo3D = {\n  top: number,\n  left: number,\n  right: number,\n  bottom: number,\n  front: number,\n  back: number,\n  type: PadType\n};\n\n/**\n * Information about the forward pass of a convolution/pooling operation.\n * It includes input and output shape, strides, filter size and padding\n * information.\n */\nexport type Conv2DInfo = {\n  batchSize: number,\n  inHeight: number,\n  inWidth: number,\n  inChannels: number,\n  outHeight: number,\n  outWidth: number,\n  outChannels: number,\n  dataFormat: 'channelsFirst'|'channelsLast',\n  strideHeight: number,\n  strideWidth: number,\n  dilationHeight: number,\n  dilationWidth: number,\n  filterHeight: number,\n  filterWidth: number,\n  effectiveFilterHeight: number,\n  effectiveFilterWidth: number,\n  padInfo: PadInfo,\n  inShape: [number, number, number, number],\n  outShape: [number, number, number, number],\n  filterShape: [number, number, number, number]\n};\n\n/**\n *\n * @param inputShape Input tensor shape is of the following dimensions:\n *     `[batch, height, width, inChannels]`.\n * @param filterShape The filter shape is of the following dimensions:\n *     `[filterHeight, filterWidth, depth]`.\n * @param strides The strides of the sliding window for each dimension of the\n *     input tensor: `[strideHeight, strideWidth]`.\n *     If `strides` is a single number,\n *     then `strideHeight == strideWidth`.\n * @param pad The type of padding algorithm.\n *    - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *    - `valid`: output will be smaller than input if filter is larger\n *       than 1*1x1.\n *    - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dataFormat The data format of the input and output data.\n *     Defaults to 'NHWC'.\n * @param dilations The dilation rates: `[dilationHeight, dilationWidth]`.\n *     Defaults to `[1, 1]`. If `dilations` is a single number, then\n *     `dilationHeight == dilationWidth`.\n */\nexport function computeDilation2DInfo(\n    inputShape: [number, number, number, number],\n    filterShape: [number, number, number], strides: number|[number, number],\n    pad: 'same'|'valid'|number, dataFormat: 'NHWC' = 'NHWC',\n    dilations: number|[number, number]) {\n  // `computerConv2DInfo` require filterShape to be in the dimension of:\n  // `[filterHeight, filterWidth, depth, outDepth]`, dilation2d doesn't have\n  // outDepth, it should have the same depth as the input.\n  // Input shape: [batch, height, width, inChannels]\n  const inputChannels = inputShape[3];\n  const $filterShape =\n      [...filterShape, inputChannels] as [number, number, number, number];\n  const $dataFormat = convertConv2DDataFormat(dataFormat);\n\n  return computeConv2DInfo(\n      inputShape, $filterShape, strides, dilations, pad,\n      null /* roundingMode */, null /* depthWise */, $dataFormat);\n}\n\nexport function computePool2DInfo(\n    inShape: [number, number, number, number],\n    filterSize: [number, number]|number, strides: number|[number, number],\n    dilations: number|[number, number],\n    pad: 'same'|'valid'|number|ExplicitPadding,\n    roundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast'): Conv2DInfo {\n  const [filterHeight, filterWidth] = parseTupleParam(filterSize);\n\n  let filterShape: [number, number, number, number];\n  if (dataFormat === 'channelsLast') {\n    filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];\n  } else if (dataFormat === 'channelsFirst') {\n    filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv2DInfo(\n      inShape, filterShape, strides, dilations, pad, roundingMode, false,\n      dataFormat);\n}\n\n/**\n * Computes the information for a forward pass of a pooling3D operation.\n */\nexport function computePool3DInfo(\n    inShape: [number, number, number, number, number],\n    filterSize: number|[number, number, number],\n    strides: number|[number, number, number],\n    dilations: number|[number, number, number], pad: 'same'|'valid'|number,\n    roundingMode?: 'floor'|'round'|'ceil',\n    dataFormat: 'NDHWC'|'NCDHW' = 'NDHWC'): Conv3DInfo {\n  const [filterDepth, filterHeight, filterWidth] = parse3TupleParam(filterSize);\n\n  let filterShape: [number, number, number, number, number];\n  let $dataFormat: 'channelsFirst'|'channelsLast';\n  if (dataFormat === 'NDHWC') {\n    $dataFormat = 'channelsLast';\n    filterShape =\n        [filterDepth, filterHeight, filterWidth, inShape[4], inShape[4]];\n  } else if (dataFormat === 'NCDHW') {\n    $dataFormat = 'channelsFirst';\n    filterShape =\n        [filterDepth, filterHeight, filterWidth, inShape[1], inShape[1]];\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  return computeConv3DInfo(\n      inShape, filterShape, strides, dilations, pad, false, $dataFormat,\n      roundingMode);\n}\n\n/**\n * Computes the information for a forward pass of a convolution/pooling\n * operation.\n */\nexport function computeConv2DInfo(\n    inShape: [number, number, number, number],\n    filterShape: [number, number, number, number],\n    strides: number|[number, number], dilations: number|[number, number],\n    pad: 'same'|'valid'|number|ExplicitPadding,\n    roundingMode?: 'floor'|'round'|'ceil', depthwise = false,\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast'): Conv2DInfo {\n  let [batchSize, inHeight, inWidth, inChannels] = [-1, -1, -1, -1];\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterHeight, filterWidth, , filterChannels] = filterShape;\n  const [strideHeight, strideWidth] = parseTupleParam(strides);\n  const [dilationHeight, dilationWidth] = parseTupleParam(dilations);\n\n  const effectiveFilterHeight =\n      getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth =\n      getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {padInfo, outHeight, outWidth} = getPadAndOutInfo(\n      pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight,\n      effectiveFilterWidth, roundingMode, dataFormat);\n\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n\n  let outShape: [number, number, number, number];\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inHeight,\n    inWidth,\n    inChannels,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideHeight,\n    strideWidth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n\n/**\n * Information about the forward pass of a 3D convolution/pooling operation.\n * It includes input and output shape, strides, filter size and padding\n * information.\n */\nexport type Conv3DInfo = {\n  batchSize: number,\n  inDepth: number,\n  inHeight: number,\n  inWidth: number,\n  inChannels: number,\n  outDepth: number,\n  outHeight: number,\n  outWidth: number,\n  outChannels: number,\n  dataFormat: 'channelsFirst'|'channelsLast',\n  strideDepth: number,\n  strideHeight: number,\n  strideWidth: number,\n  dilationDepth: number,\n  dilationHeight: number,\n  dilationWidth: number,\n  filterDepth: number,\n  filterHeight: number,\n  filterWidth: number,\n  effectiveFilterDepth: number,\n  effectiveFilterHeight: number,\n  effectiveFilterWidth: number,\n  padInfo: PadInfo3D,\n  inShape: [number, number, number, number, number],\n  outShape: [number, number, number, number, number],\n  filterShape: [number, number, number, number, number]\n};\n\n/**\n * Computes the information for a forward pass of a 3D convolution/pooling\n * operation.\n */\nexport function computeConv3DInfo(\n    inShape: [number, number, number, number, number],\n    filterShape: [number, number, number, number, number],\n    strides: number|[number, number, number],\n    dilations: number|[number, number, number], pad: 'same'|'valid'|number,\n    depthwise = false,\n    dataFormat: 'channelsFirst'|'channelsLast' = 'channelsLast',\n    roundingMode?: 'floor'|'round'|'ceil'): Conv3DInfo {\n  let [batchSize, inDepth, inHeight, inWidth, inChannels] =\n      [-1, -1, -1, -1, -1];\n  if (dataFormat === 'channelsLast') {\n    [batchSize, inDepth, inHeight, inWidth, inChannels] = inShape;\n  } else if (dataFormat === 'channelsFirst') {\n    [batchSize, inChannels, inDepth, inHeight, inWidth] = inShape;\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n\n  const [filterDepth, filterHeight, filterWidth, , filterChannels] =\n      filterShape;\n  const [strideDepth, strideHeight, strideWidth] = parse3TupleParam(strides);\n  const [dilationDepth, dilationHeight, dilationWidth] =\n      parse3TupleParam(dilations);\n\n  const effectiveFilterDepth =\n      getEffectiveFilterSize(filterDepth, dilationDepth);\n  const effectiveFilterHeight =\n      getEffectiveFilterSize(filterHeight, dilationHeight);\n  const effectiveFilterWidth =\n      getEffectiveFilterSize(filterWidth, dilationWidth);\n  const {padInfo, outDepth, outHeight, outWidth} = get3DPadAndOutInfo(\n      pad, inDepth, inHeight, inWidth, strideDepth, strideHeight, strideWidth,\n      effectiveFilterDepth, effectiveFilterHeight, effectiveFilterWidth,\n      roundingMode);\n\n  const outChannels = depthwise ? filterChannels * inChannels : filterChannels;\n\n  let outShape: [number, number, number, number, number];\n  if (dataFormat === 'channelsFirst') {\n    outShape = [batchSize, outChannels, outDepth, outHeight, outWidth];\n  } else if (dataFormat === 'channelsLast') {\n    outShape = [batchSize, outDepth, outHeight, outWidth, outChannels];\n  }\n\n  return {\n    batchSize,\n    dataFormat,\n    inDepth,\n    inHeight,\n    inWidth,\n    inChannels,\n    outDepth,\n    outHeight,\n    outWidth,\n    outChannels,\n    padInfo,\n    strideDepth,\n    strideHeight,\n    strideWidth,\n    filterDepth,\n    filterHeight,\n    filterWidth,\n    effectiveFilterDepth,\n    effectiveFilterHeight,\n    effectiveFilterWidth,\n    dilationDepth,\n    dilationHeight,\n    dilationWidth,\n    inShape,\n    outShape,\n    filterShape\n  };\n}\n\nfunction computeOutputShape2D(\n    inShape: [number, number], fieldSize: number, stride: number,\n    zeroPad?: number, roundingMode?: 'floor'|'round'|'ceil'): [number, number] {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, fieldSize, stride);\n  }\n  const inputRows = inShape[0];\n  const inputCols = inShape[1];\n\n  const outputRows =\n      round((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n  const outputCols =\n      round((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);\n\n  return [outputRows, outputCols];\n}\n\nfunction computeOutputShape4D(\n    inShape: [number, number, number, number],\n    filterShape: [number, number, number], outChannels: number,\n    strides: [number, number, number], zeroPad?: number,\n    roundingMode?: 'floor'|'round'|'ceil'): [number, number, number, number] {\n  if (zeroPad == null) {\n    zeroPad = computeDefaultPad(inShape, filterShape[0], strides[0]);\n  }\n  const outShape: [number, number, number, number] = [0, 0, 0, outChannels];\n  for (let index = 0; index < 3; index++) {\n    if (inShape[index] + 2 * zeroPad >= filterShape[index]) {\n      outShape[index] = round(\n          (inShape[index] - filterShape[index] + 2 * zeroPad) / strides[index] +\n              1,\n          roundingMode);\n    }\n  }\n  return outShape;\n}\n\nexport function computeDefaultPad(\n    inputShape: [number, number]|[number, number, number, number],\n    fieldSize: number, stride: number, dilation = 1): number {\n  const effectiveFieldSize = getEffectiveFilterSize(fieldSize, dilation);\n  return Math.floor(\n      (inputShape[0] * (stride - 1) - stride + effectiveFieldSize) / 2);\n}\n\nfunction parseTupleParam(param: number|number[]): [number, number, number] {\n  if (typeof param === 'number') {\n    return [param, param, param];\n  }\n  if (param.length === 2) {\n    return [param[0], param[1], 1];\n  }\n  return param as [number, number, number];\n}\n\nfunction parse3TupleParam(param: number|[number, number, number]):\n    [number, number, number] {\n  return typeof param === 'number' ? [param, param, param] : param;\n}\n\n/* See https://www.tensorflow.org/api_docs/python/tf/nn/atrous_conv2d\n * Atrous convolution is equivalent to standard convolution with upsampled\n * filters with effective_filter_height =\n * filter_height + (filter_height - 1) * (dilation - 1)\n * and effective_filter_width =\n * filter_width + (filter_width - 1) * (dilation - 1),\n * produced by inserting dilation - 1 zeros along consecutive elements across\n * the filters' spatial dimensions.\n * When there is a dilation, this converts a filter dimension to the\n * effective filter dimension, so it can be used in a standard convolution.\n */\nfunction getEffectiveFilterSize(filterSize: number, dilation: number) {\n  if (dilation <= 1) {\n    return filterSize;\n  }\n\n  return filterSize + (filterSize - 1) * (dilation - 1);\n}\n\nfunction getPadAndOutInfo(\n    pad: 'same'|'valid'|number|ExplicitPadding, inHeight: number,\n    inWidth: number, strideHeight: number, strideWidth: number,\n    filterHeight: number, filterWidth: number,\n    roundingMode: 'floor'|'round'|'ceil',\n    dataFormat: 'channelsFirst'|\n    'channelsLast'): {padInfo: PadInfo, outHeight: number, outWidth: number} {\n  let padInfo: PadInfo;\n  let outHeight: number;\n  let outWidth: number;\n\n  if (typeof pad === 'number') {\n    const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n    padInfo = {top: pad, bottom: pad, left: pad, right: pad, type: padType};\n    const outShape = computeOutputShape2D(\n        [inHeight, inWidth], filterHeight, strideHeight, pad, roundingMode);\n    outHeight = outShape[0];\n    outWidth = outShape[1];\n  } else if (pad === 'same') {\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongHeight =\n        Math.max(0, (outHeight - 1) * strideHeight + filterHeight - inHeight);\n    const padAlongWidth =\n        Math.max(0, (outWidth - 1) * strideWidth + filterWidth - inWidth);\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n    padInfo = {top, bottom, left, right, type: 'SAME'};\n  } else if (pad === 'valid') {\n    padInfo = {top: 0, bottom: 0, left: 0, right: 0, type: 'VALID'};\n    outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);\n    outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);\n  } else if (typeof pad === 'object') {\n    const top = dataFormat === 'channelsLast' ? pad[1][0] : pad[2][0];\n    const bottom = dataFormat === 'channelsLast' ? pad[1][1] : pad[2][1];\n    const left = dataFormat === 'channelsLast' ? pad[2][0] : pad[3][0];\n    const right = dataFormat === 'channelsLast' ? pad[2][1] : pad[3][1];\n    const padType = (top === 0 && bottom === 0 && left === 0 && right === 0) ?\n        'VALID' :\n        'EXPLICIT';\n    padInfo = {top, bottom, left, right, type: padType};\n    outHeight = round(\n        (inHeight - filterHeight + top + bottom) / strideHeight + 1,\n        roundingMode);\n    outWidth = round(\n        (inWidth - filterWidth + left + right) / strideWidth + 1, roundingMode);\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n  return {padInfo, outHeight, outWidth};\n}\n\nfunction get3DPadAndOutInfo(\n    pad: 'same'|'valid'|number, inDepth: number, inHeight: number,\n    inWidth: number, strideDepth: number, strideHeight: number,\n    strideWidth: number, filterDepth: number, filterHeight: number,\n    filterWidth: number, roundingMode?: 'floor'|'round'|'ceil'): {\n  padInfo: PadInfo3D,\n  outDepth: number,\n  outHeight: number,\n  outWidth: number\n} {\n  let padInfo: PadInfo3D;\n  let outDepth: number;\n  let outHeight: number;\n  let outWidth: number;\n\n  if (pad === 'valid') {\n    pad = 0;\n  }\n\n  if (typeof pad === 'number') {\n    const padType = (pad === 0) ? 'VALID' : 'NUMBER';\n    padInfo = {\n      top: pad,\n      bottom: pad,\n      left: pad,\n      right: pad,\n      front: pad,\n      back: pad,\n      type: padType\n    };\n    const outShape = computeOutputShape4D(\n        [inDepth, inHeight, inWidth, 1],\n        [filterDepth, filterHeight, filterWidth], 1,\n        [strideDepth, strideHeight, strideWidth], pad, roundingMode);\n    outDepth = outShape[0];\n    outHeight = outShape[1];\n    outWidth = outShape[2];\n  } else if (pad === 'same') {\n    outDepth = Math.ceil(inDepth / strideDepth);\n    outHeight = Math.ceil(inHeight / strideHeight);\n    outWidth = Math.ceil(inWidth / strideWidth);\n    const padAlongDepth = (outDepth - 1) * strideDepth + filterDepth - inDepth;\n    const padAlongHeight =\n        (outHeight - 1) * strideHeight + filterHeight - inHeight;\n    const padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;\n    const front = Math.floor(padAlongDepth / 2);\n    const back = padAlongDepth - front;\n    const top = Math.floor(padAlongHeight / 2);\n    const bottom = padAlongHeight - top;\n    const left = Math.floor(padAlongWidth / 2);\n    const right = padAlongWidth - left;\n\n    padInfo = {top, bottom, left, right, front, back, type: 'SAME'};\n  } else {\n    throw Error(`Unknown padding parameter: ${pad}`);\n  }\n  return {padInfo, outDepth, outHeight, outWidth};\n}\n\n/**\n * Rounds a value depending on the rounding mode\n * @param value\n * @param roundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n */\nfunction round(value: number, roundingMode?: 'floor'|'round'|'ceil') {\n  if (!roundingMode) {\n    return Math.trunc(value);\n  }\n  switch (roundingMode) {\n    case 'round':\n      // used for Caffe Conv\n      return Math.round(value);\n    case 'ceil':\n      // used for Caffe Pool\n      return Math.ceil(value);\n    case 'floor':\n      return Math.floor(value);\n    default:\n      throw new Error(`Unknown roundingMode ${roundingMode}`);\n  }\n}\n\nexport function tupleValuesAreOne(param: number|number[]): boolean {\n  const [dimA, dimB, dimC] = parseTupleParam(param);\n  return dimA === 1 && dimB === 1 && dimC === 1;\n}\n\nexport function eitherStridesOrDilationsAreOne(\n    strides: number|number[], dilations: number|number[]): boolean {\n  return tupleValuesAreOne(strides) || tupleValuesAreOne(dilations);\n}\n\nexport function stridesOrDilationsArePositive(values: number|\n                                              number[]): boolean {\n  return parseTupleParam(values).every(value => value > 0);\n}\n\n/**\n * Convert Conv2D dataFormat from 'NHWC'|'NCHW' to\n *    'channelsLast'|'channelsFirst'\n * @param dataFormat in 'NHWC'|'NCHW' mode\n * @return dataFormat in 'channelsLast'|'channelsFirst' mode\n * @throws unknown dataFormat\n */\nexport function convertConv2DDataFormat(dataFormat: 'NHWC'|'NCHW'):\n    'channelsLast'|'channelsFirst' {\n  if (dataFormat === 'NHWC') {\n    return 'channelsLast';\n  } else if (dataFormat === 'NCHW') {\n    return 'channelsFirst';\n  } else {\n    throw new Error(`Unknown dataFormat ${dataFormat}`);\n  }\n}\n\n/**\n * Check validity of pad when using dimRoundingMode.\n * @param opDesc A string of op description\n * @param pad The type of padding algorithm.\n *   - `same` and stride 1: output will be of same size as input,\n *       regardless of filter size.\n *   - `valid` output will be smaller than input if filter is larger\n *       than 1x1.\n *   - For more info, see this guide:\n *     [https://www.tensorflow.org/api_docs/python/tf/nn/convolution](\n *          https://www.tensorflow.org/api_docs/python/tf/nn/convolution)\n * @param dimRoundingMode A string from: 'ceil', 'round', 'floor'. If none is\n *     provided, it will default to truncate.\n * @throws unknown padding parameter\n */\nexport function checkPadOnDimRoundingMode(\n    opDesc: string, pad: 'valid'|'same'|number|ExplicitPadding,\n    dimRoundingMode?: 'floor'|'round'|'ceil') {\n  if (dimRoundingMode != null) {\n    if (typeof pad === 'string') {\n      throw Error(\n          `Error in ${opDesc}: pad must be an integer when using ` +\n          `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'number') {\n      util.assert(\n          util.isInt(pad),\n          () => `Error in ${opDesc}: pad must be an integer when using ` +\n              `dimRoundingMode ${dimRoundingMode} but got pad ${pad}.`);\n    } else if (typeof pad === 'object') {\n      (pad as ExplicitPadding).forEach(p => {\n        p.forEach(v => {\n          util.assert(\n              util.isInt(v),\n              () => `Error in ${opDesc}: pad must be an integer when using ` +\n                  `dimRoundingMode ${dimRoundingMode} but got pad ${v}.`);\n        });\n      });\n    } else {\n      throw Error(`Error in ${opDesc}: Unknown padding parameter: ${pad}`);\n    }\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}