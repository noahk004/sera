{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { backend_util, util } from '@tensorflow/tfjs-core';\nexport function sparseReshapeImpl(inputIndices, inputIndicesShape, inputDType, inputShape, targetShape) {\n  const denseSize = util.sizeFromShape(inputShape);\n  const nnz = inputIndicesShape[0];\n  const outputRank = targetShape.length;\n  // Compute the output shape. Determine product of specified dimensions, and\n  // find the index of the unspecified one.\n  const outputShape = [];\n  let product = 1;\n  let unknownIndex = -1;\n  for (let d = 0; d < outputRank; ++d) {\n    const size = targetShape[d];\n    if (size === -1) {\n      if (unknownIndex !== -1) {\n        throw new Error(backend_util.getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(unknownIndex, d));\n      }\n      unknownIndex = d;\n      outputShape.push(1);\n    } else {\n      if (size < 0) {\n        throw new Error(backend_util.getSparseReshapeNegativeOutputDimErrorMessage(d, size));\n      }\n      product *= size;\n      outputShape.push(size);\n    }\n  }\n  if (unknownIndex !== -1) {\n    if (product <= 0) {\n      throw new Error(backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());\n    }\n    const missing = Math.trunc(denseSize / product);\n    if (product * missing !== denseSize) {\n      throw new Error(backend_util.getSparseReshapeInputOutputMultipleErrorMessage(inputShape, outputShape));\n    }\n    outputShape[unknownIndex] = missing;\n  }\n  const outputSize = util.sizeFromShape(outputShape);\n  if (outputSize !== denseSize) {\n    throw new Error(backend_util.getSparseReshapeInputOutputMismatchErrorMessage(inputShape, outputShape));\n  }\n  const inputRank = inputShape.length;\n  const inputStrides = [];\n  if (inputRank > 0) {\n    inputStrides[inputRank - 1] = 1;\n    for (let d = inputRank - 2; d >= 0; --d) {\n      inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];\n    }\n  }\n  const outputStrides = [];\n  if (outputRank > 0) {\n    outputStrides[outputRank - 1] = 1;\n    for (let d = outputRank - 2; d >= 0; --d) {\n      outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];\n    }\n  }\n  const newIndices = util.getArrayFromDType(inputDType, nnz * outputRank);\n  for (let i = 0; i < nnz; ++i) {\n    let id = 0;\n    for (let j = 0; j < inputRank; ++j) {\n      // inputIndices is a 2d tensor with shape of [nnz, inputRank]\n      id += inputIndices[i * inputRank + j] * inputStrides[j];\n    }\n    for (let j = 0; j < outputRank; ++j) {\n      // newIndices is a 2d tensor with shape of [nnz, outputRank]\n      newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);\n      id %= outputStrides[j];\n    }\n  }\n  return [newIndices, [nnz, outputRank], outputShape];\n}","map":{"version":3,"sources":["../../../../../../tfjs-backend-cpu/src/kernels/SparseReshape_impl.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {backend_util, DataType, TypedArray, util} from '@tensorflow/tfjs-core';\n\nexport function sparseReshapeImpl(\n    inputIndices: TypedArray, inputIndicesShape: number[], inputDType: DataType,\n    inputShape: number[],\n    targetShape: number[]): [TypedArray, number[], number[]] {\n  const denseSize = util.sizeFromShape(inputShape);\n  const nnz = inputIndicesShape[0];\n  const outputRank = targetShape.length;\n\n  // Compute the output shape. Determine product of specified dimensions, and\n  // find the index of the unspecified one.\n  const outputShape: number[] = [];\n  let product = 1;\n  let unknownIndex = -1;\n  for (let d = 0; d < outputRank; ++d) {\n    const size = targetShape[d];\n    if (size === -1) {\n      if (unknownIndex !== -1) {\n        throw new Error(\n            backend_util\n                .getSparseReshapeMultipleNegativeOneOutputDimErrorMessage(\n                    unknownIndex, d));\n      }\n      unknownIndex = d;\n      outputShape.push(1);\n    } else {\n      if (size < 0) {\n        throw new Error(\n            backend_util.getSparseReshapeNegativeOutputDimErrorMessage(\n                d, size));\n      }\n      product *= size;\n      outputShape.push(size);\n    }\n  }\n  if (unknownIndex !== -1) {\n    if (product <= 0) {\n      throw new Error(\n          backend_util.getSparseReshapeEmptyTensorZeroOutputDimErrorMessage());\n    }\n    const missing = Math.trunc(denseSize / product);\n    if (product * missing !== denseSize) {\n      throw new Error(\n          backend_util.getSparseReshapeInputOutputMultipleErrorMessage(\n              inputShape, outputShape));\n    }\n\n    outputShape[unknownIndex] = missing;\n  }\n  const outputSize = util.sizeFromShape(outputShape);\n  if (outputSize !== denseSize) {\n    throw new Error(\n        backend_util.getSparseReshapeInputOutputMismatchErrorMessage(\n            inputShape, outputShape));\n  }\n\n  const inputRank = inputShape.length;\n  const inputStrides: number[] = [];\n  if (inputRank > 0) {\n    inputStrides[inputRank - 1] = 1;\n    for (let d = inputRank - 2; d >= 0; --d) {\n      inputStrides[d] = inputStrides[d + 1] * inputShape[d + 1];\n    }\n  }\n\n  const outputStrides: number[] = [];\n  if (outputRank > 0) {\n    outputStrides[outputRank - 1] = 1;\n    for (let d = outputRank - 2; d >= 0; --d) {\n      outputStrides[d] = outputStrides[d + 1] * outputShape[d + 1];\n    }\n  }\n\n  const newIndices =\n      util.getArrayFromDType(inputDType, nnz * outputRank) as TypedArray;\n  for (let i = 0; i < nnz; ++i) {\n    let id = 0;\n    for (let j = 0; j < inputRank; ++j) {\n      // inputIndices is a 2d tensor with shape of [nnz, inputRank]\n      id += inputIndices[i * inputRank + j] * inputStrides[j];\n    }\n    for (let j = 0; j < outputRank; ++j) {\n      // newIndices is a 2d tensor with shape of [nnz, outputRank]\n      newIndices[i * outputRank + j] = Math.trunc(id / outputStrides[j]);\n      id %= outputStrides[j];\n    }\n  }\n  return [newIndices, [nnz, outputRank], outputShape];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}